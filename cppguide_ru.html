<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Руководство Google по стилю в C++</title>
<link rel="stylesheet" href="include/styleguide_ru.css" />
<script src="include/styleguide_ru.js"></script>
<link rel="shortcut icon" href="https://www.google.com/favicon.ico" />
</head>
<body onload="initStyleGuide();">
<div id="content">
<h1>Руководство Google по стилю в C++</h1>
<div class="horizontal_toc" id="tocDiv"></div>
<div class="main_body">

<h2 id="Background" class="ignoreLink">Вступление</h2>

<p>C++ один из основных языков программирования, используемый в open-source проектах Google.
Известно, что C++ очень мощный язык. Вместе с тем это сложный язык и, при неправильном использовании,
может быть рассадником багов, затруднить чтение и поддержку кода.</p>

<p>Цель руководства - управлять сложностью кода,
 описывая в деталях как стоит (или не стоит) писать код на C++.
Правила этого руководства упростят управление кодом и увеличат продуктивность кодеров.</p>

<p><em>Style / Стиль</em> - соглашения, которым следует C++ код.
Стиль - это больше, чем форматирование файла с кодом.</p>

<p>Большинство open-source проектов, разрабатываемых Google, соответствуют этому руководству.</p>

<p>Примечание: это руководство не является учебником по C++:
предполагается, что вы знакомы с языком.</p>

<h3 id="Goals">Цели Руководства по стилю</h3>

<p>Зачем нужен этот документ?</p>

<p>Есть несколько основных целей этого документа, внутренних
 <b>Зачем</b>, лежащих в основе отдельных правил.
Используя эти цели можно избежать длинных дискуссий: почему правила такие и зачем им следовать.
 Если вы понимаете цели каждого правила, то вам легче с ними согласиться или отвергнуть,
 оценить альтернативы при изменении правил под себя.</p>

<p>Цели руководства следующие::</p>
<dl>
<dt>Правила должны стоить изменений</dt>
<dd>Преимущества от использования единого стиля должны перевешивать 
 недовольство инженеров по запоминанию и использованию правил.
 Преимущество оценивается по сравнению с кодовой базой без применения правил,
 поэтому если ваши люди всё равно не будут применять правила,
 то выгода будет очень небольшой.
 Этот принцип объясняет почему некоторые правила отсутствуют:
 например, <code>goto</code> нарушает многие принципы, однако он практически не используется,
 поэтому Руководство это не описывает.</dd>

<dt>Оптимизировано для чтения, не для написания</dt>
<dd>Наша кодовая база (и большинство отдельных компонентов из неё)
 будет использоваться продолжительное время. Поэтому, на чтение этого кода
 будет тратиться существенно больше времени, чем на написание.
 Мы явно заботимся чтобы нашим инженерам было лего читать, поддерживать,
 отлаживать код. "Оставляй отладочный/логирующий код" - одно из следствий:
 когда кусок кода работает "странно" (например, при передаче владения указателем),
 наличие текстовых подсказок может быть очень полезным (<code>std::unique_ptr</code>
 явно показывает передачу владения). </dd>

<dt>Пиши код, похожий на существующий</dt>
<dd>Использование единого стиля на кодовой базе позволяет переключиться на другие, более важные, вопросы.
 Также, единый стиль способствует автоматизации. И, конечно, автоформат кода
 (или выравнивание <code>#include</code>-ов) работает правильно, если он
 соответствует требованиям утилиты. В остальных случаях из набора правил
 применяется только одно (наиболее подходящее), а некоторая гибкость в
 использовании правил позволяет людям меньше спорить.</dd>

<dt>Пиши код, похожий на используемый в C++ сообщества (по возможности)</dt>
<dd>Согласованность нашего кода с C++ кодом других организаций и сообществ
 весьма полезна. Если возможности стандартного C++ или принятые идиомы языка
 облегчают написание программ, это повод использовать их. Однако,
 иногда стандарт и идиомы плохо подходят для задачи. В этих случаях
 (как описано ниже) имеет смысл ограничить или запретить использование
 некоторых стандартных возможностей. В некоторых случаях создаётся свой решение,
 но иногда используются внешние библиотеки (вместо стандартной библиотеки C++)
 и переписывание её под свой стандарт слишком затратно.</dd>

<dt>Избегайте неожиданных или опасных конструкций</dt>
<dd>В языке C++ есть неочевидные и даже опасные подходы. Некоторые
 стили кодирования ограничивают их использование, т.к. их использование 
несёт большие риски для правильности кода.</dd>

<dt>Избегайте конструкций, которые средний C++ программист считает заумными
 и сложно поддерживаемыми</dt>
<dd>В C++ есть возможности, которые в целом не приветствуются по причине
 усложнения кода. Однако, в часто используемом коде применение хитрых
 конструкций более оправданно благодаря многократному использованию,
 также новые порции кода станут более понятны.
 В случае сомнений - проконсультируйтесь с лидером проекта.
 Это очень важно для нашей кодовой базы, т.к. владельцы кода и команда поддержки
 меняются со временем: даже если сейчас все понимают код,
 через несколько лет всё может исзмениться.</dd>

<dt>Учитывайте масштаб кода</dt>
<dd>С кодовой базой более 100 миллионов строк и тысячами инженеров,
 ошибки и упрощения могут дорого обойтись. Например, важно избегать
 замусоривания глобального пространства имён: коллизии имён очень 
 сложно избежать в большой базе кода если всё объявляется в глобальном
 пространстве имён.</dd>

<dt>Оптимизируйте по необходимости</dt>
<dd>Оптимизация производительности иногда важнее, чем следование правилам в кодировании.</dd>
</dl>

<p>Намерение этого документа - обеспечить максимально понятное руководство
 при разумных ограничениях. Как всегда, здравый смысл никто не отменял.
 Этой спецификацией мы хотим установить соглашения для всего сообщества Google в C++,
 не только для отдельных команд или людей. Относитесь со скепсисом к хитрым или
 необычным конструкциям: отсутствие ограничения не всегда есть разрешение.
 И, если не можешь решить сам, спроси начальника.</p>



<h2 id="C++_Version">Версия C++</h2>

<p>Сейчас код должен соответствовать C++17, т.е. возможности C++2x нежелательны.
 В дальнейшем, руководство будет корректироваться на более новые версии C++.</p>

<p>Не используйте
  <a href="#Nonstandard_Extensions">нестандартные расширения</a>.</p>

<p>Учитывайте совместимость с другим окружением, если собираетесь
 использовать C++14 and C++17 в своём проекте.</p>

<h2 id="Header_Files">Заголовочные файлы</h2>

<p>Желательно, чтобы каждый <code>.cc</code> файл исходного кода
 имел парный <code>.h</code> заголовочный файл. Также есть известные
 исключения из этого правила, такие как юниттесты или небольшие
 <code>.cc</code> файлы, содержащие только функцию <code>main()</code>.</p>

<p>Правильное использование заголовочных файлов может оказать
 огромное влияние на читабельность, размер и производительность вашего кода.</p>

<p>Следующие правила позволят избежать частых проблем с заголовочными файлами.</p>

<h3 id="Self_contained_Headers">Независимые заголовочные файлы</h3>

<p>Заголовочные файлы должны быть самодостаточными (в плане компиляции)
 и иметь расширение <code>.h</code>. Другие файлы (не заголовочные), предназначенные
 для включения в код, должны быть с расширением <code>.inc</code> и использоваться
 в паре с включающим кодом.</p>

<p>Все заголовочные файлы должны быть самодостаточыми. Пользователи и инструменты разработки не
 должны зависеть от специальных зависимостей при использовании заголовочного файла.
 Заголовочный файл должен иметь <a href="#The__define_Guard">блокировку от повторного включения</a> и
 включать все необходимые файлы.</p>

<p>Предпочтительно размещать определения для шаблонов и inline-функций
 в одном файле с их декларациями. И эти определения должны быть 
 включены (include) в каждый <code>.cc</code> файл, использующий их, иначе
 могут быть ошибки линковки на некоторых конфигурациях сборки. Если же
 декларации и определения находятся в разных файлах, включение одного должно
 подключать другой. Не выделяйте определения в отдельные заголовочные файлы
 (<code>-inl.h</code>). Раньше такая практика была очень популярна, сейчас
 это нежелательно.</p>

<p>Как исключение, если из шаблона создаются все доступные варианты
 шаблонных аргументов или если шаблон реализует функционал, используемый
 только одним классом - тогда допустимо определять шаблон в одном
 (и только одном) <code>.cc</code> файле, в котором этот шаблон и используется.</p>

<p>Возможны редкие ситуации, когда заголовочный файл не самодостаточный.
 Это может происходить, когда файл подключается в нестандартном месте,
 например в середине другого файла. В этом случае может отсутствовать
 <a href="#The__define_Guard">блокировка от повторного включения</a>, и
 дополнительные заголовочные файлы также могут не подключаться.
 Именуйте такие файлы расширением <code>.inc</code>. Используйте их парой и
 старайтесь чтобы они максимально соответствовали общим требованиям.</p>

<h3 id="The__define_Guard">Блокировка от повторного включения</h3>

<p>Все заголовочные файлы должны быть с защитой от повторного включения посредством
 <code>#define</code>. Формат макроопределения должен быть:

<code><i>&lt;PROJECT&gt;</i>_<i>&lt;PATH&gt;</i>_<i>&lt;FILE&gt;</i>_H_</code>.</p>

<div>
<p>Для гарантии уникальности, используйте компоненты полного пути к файлу в дереве проекта.
 Например, файл <code>foo/src/bar/baz.h</code> в проекте <code>foo</code> может иметь следующую блокировку:</p>
</div>

<pre>#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
</pre>



<h3 id="Forward_Declarations">Предварительное объявление</h3>

<p>По возможности, не используйте предварительное объявление.
 Вместо этого делайте <code>#include</code> необходимых заголовочных файлов.</p>

<p class="definition"></p>
<p>"Предварительное объявление" - декларация класса, функции, шаблона без
 соответствующего определения.</p>

<p class="pros"></p>
<ul>
  <li>Предварительной объявление может уменьшить время компиляции.
 Использование <code>#include</code> требует от компилятора сразу
 открывать (и обрабатывать) больше файлов.</li>

  <li>Предварительное объявление позволит избежать ненужной
 перекомпиляции. Применение <code>#include</code> может привести к
 частой перекомпиляции из-за различных изменений в заголовочных файлах.</li>
</ul>

<p class="cons"></p>
<ul>
  <li>Предварительное объявление может скрывать от перекомпиляции
 зависимости, которые изменились.</li>

  <li>При изменении API, предварительное объявление может стать некорректным.
 Как результат, предварительное объявление функция или шаблонов может блокировать
 изменение API: замена типов параметров на похожий, добавление параметров
 по умолчанию в шаблон, перенос в новое пространство имён.</li>

  <li>Предварительное объявление символов из <code>std::</code> может вызвать
 неопределённое поведение.</li>

  <li>Иногда тяжело понять, что лучше подходит: предварительное объявление или
 обычный <code>#include</code>.
 Однако, замена <code>#include</code> на предварительное объявление может (без предупреждений) поменять
 смысл кода:
      <pre>      // b.h:
      struct B {};
      struct D : B {};

      // good_user.cc:
      #include "b.h"
      void f(B*);
      void f(void*);
      void test(D* x) { f(x); }  // calls f(B*)
      </pre>
  Если в коде заменить <code>#include</code> на предварительное объявление
 для структур <code>B</code> и <code>D</code>, то 
  <code>test()</code> будет вызывать <code>f(void*)</code>.
  </li>

  <li>Предварительное объявление множества сущностей может быть
    чересчур объёмным, и может быть проще подключить заголовочный файл.</li>

  <li>Структура кода, допускающая предварительное объявление
    (и, далее, использование указателей в качестве членов класса)
    может сделать код запутанным и медленным.</li>

</ul>

<p class="decision"></p>
<ul>
  <li>Старайтесь избегать предварительного объявления сущностей,
    объявленных в другом проекте.</li>

  <li>Когда используйте функцию, объявленную в заголовочном файле,
    всегда <code>#include</code> этот файл.</li>

  <li>Когда используйте шаблон класса, предпочтительно
    <code>#include</code> его заголовочный файл.</li>
</ul>

<p>Также смотри правила включения в <a href="#Names_and_Order_of_Includes">Имена и Порядок включения (include)</a>.</p>

<h3 id="Inline_Functions">Встраиваемые (inline) функции</h3>

<p>Определяйте функции как встраиваемые только когда они маленькие,
 например не более 10 строк.</p>

<p class="definition"></p>
<p>Вы можете объявлять функции встраиваемыми и указать компилятору на возможность
 включать её напрямую в вызывающий код, помимо стандартного способа с вызовом функции.</p>

<p class="pros"></p>
<p>Использование встраиваемых функций может генерировать более эффективный код,
 особенно когда функции маленькие. Используйте эту возможность для get/set функций,
 других коротких и критичных для производительности функций.</p>

<p class="cons"></p>
<p>Чрезмерное использование встраиваемых функций может сделать программу медленнее.
 Также встраиваемые функции, в зависимости от размера её, могут как увеличить, так и уменьшить
 размер кода. Если это маленькие функции, то код может быть уменьшен.
 Если же функция большая, то размер кода может очень сильно вырасти.
 Учтите, что на современных процессорах более компактный код выполняется быстрее
 благодаря лучшему использованию кэша инструкций.</p>

<p class="decision"></p>
<p>Хорошим правилом будет не делать функции встраиваемыми, если они превышают
 10 строк кода. Избегайте делать встраиваемыми деструкторы, т.к. они неявно
 могут содержать много дополнительного кода: вызовы деструкторов переменных и
 базовых классов!</p>

<p>Ещё одно хорошее правило: обычно нет смысла делать встраиваемыми функции,
 в которых есть циклы или операции switch (кроме вырожденных случаев, когда цикл
 или другие операторы никогда не выполняются).</p>

<p>Важно понимать, что встраиваемая функция не обязательно будет скомпилирована
 в код именно так. Например, обычно виртуальные и рекурсивные функции компилируются
 со стандартным вызовом. Вообще, рекурсивные функции не должны объявляться встраиваемыми.
 Основная же причина делать встраиваемые виртуальные функции - разместить определение (код)
 в самом определении класса (для документирования поведения или удобства чтения) - часто
 используется для get/set функций.</p>

<h3 id="Names_and_Order_of_Includes">Имена и Порядок включения (include)</h3>

<p>Вставляйте заголовочные файлы в следующем порядке:
 парный файл (например, foo.h - foo.cc), системные файлы C, стандартная библиотека C++,
 другие библиотеки, файлы вашего проекта.</p>

<p>
Все заголовочные файлы проекта должны указываться относительно
 директории исходных файлов проекта без использования таких UNIX псевдонимов
 как <code>.</code> (текущая директория) или <code>..</code>
 (родительская директория). Например,
 <code>google-awesome-project/src/base/logging.h</code>
 должен включаться так:</p>

<pre>#include "base/logging.h"
</pre>

<p>Другой пример: если основная функция файлов <code><var>dir/foo</var>.cc</code> и
<code><var>dir/foo_test</var>.cc</code> 
 это реализация и тестирование кода, объявленного в 
 <code><var>dir2/foo2</var>.h</code>, то записывайте заголовочные файлы
 в следующем порядке:</p>

<ol>
  <li><code><var>dir2/foo2</var>.h</code>.</li>

  <li>------ Пустая строка</li>

  <li>Системные заголовочные файлы C (точнее: файлы с включением угловыми скобками
    с расширением <code>.h</code>), например <code>&lt;unistd.h&gt;</code>,
    <code>&lt;stdlib.h&gt;</code>.</li>

  <li>------ Пустая строка</li>

  <li>Заголовочные файлы стандартной библиотеки C++ (без расширения в файлах), например
    <code>&lt;algorithm&gt;</code>, <code>&lt;cstddef&gt;</code>.</li>

  <li>------ Пустая строка</li>

  <li>Заголовочные <code>.h</code> файлы других библиотек.</li>

  <li>Файлы <code>.h</code> вашего проекта.</li>
</ol>

<p>Отделяйте каждую (непустую) группу файлов пустой строкой.</p>

<p>Такой порядок файлов позволяет выявить ошибки, когда 
 в парном заголовочном файле (<code><var>dir2/foo2</var>.h</code>)
 пропущены необходимые заголовочные файлы (системные и др.) и
 сборка соответствующих файлов <code><var>dir/foo</var>.cc</code>
 или <code><var>dir/foo</var>_test.cc</code> завершится ошибкой.
 Как результат, ошибка сразу же появится у разработчика,
 работающего с этими файлами (а не у другой команды,
 которая только использует внешнюю библиотеку).</p>

<p>Обычно парные файлы <code><var>dir/foo</var>.cc</code> и
 <code><var>dir2/foo2</var>.h</code> находятся в одной директории
 (например, <code>base/basictypes_test.cc</code> и
 <code>base/basictypes.h</code>), хотя это не обязательно.</p>

<p>Учтите, что заголовочные файлы C, такие как <code>stddef.h</code>
 обычно взаимозаменяемы соответствующими файлами C++ (<code>cstddef</code>).
 Можно использовать любой вариант, но лучше следовать стилю
 существующего кода.</p>

<p>Внутри каждой секции заголовочные файлы лучше всего перечислять в алфавитном порядке.
 Учтите, что ранее написанный код может не следовать этому правилу. По возможности
 (например, при исправлениях в файле), исправляйте порядок файлов на правильный.</p>

<p>Следует включать все заголовочные файлы, которые объявляют требуемые вам типы,
 за исключением случаев <a href="#Forward_Declarations">предварительного объявления</a>.
 Если ваш код использует типы из <code>bar.h</code>, не полагайтесь на то, что
 другой файл <code>foo.h</code> включает <code>bar.h</code> и вы можете ограничиться включением только <code>foo.h</code>:
 включайте явно <code>bar.h</code> (кроме случаев, когда явно указано (возможно, в документации),
 что <code>foo.h</code> также выдаст вам типы из <code>bar.h</code>).</p>

<p>Например, список заголовочных файлов в
 <code>google-awesome-project/src/foo/internal/fooserver.cc</code>
 может выглядеть так:</p>

<pre>#include "foo/server/fooserver.h"

#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

#include &lt;string&gt;
#include &lt;vector&gt;

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
</pre>

<p><b>Исключения:</b></p>

<p>Бывают случаи, когда требуется включение заголовочных файлов в зависимости
 от условий препроцессора (например, в зависимости от используемой ОС).
 Такое включение старайтесь делать как можно короче (локализованно) и размещать после
 других заголовочных файлов. Например:</p>

<pre>#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include &lt;initializer_list&gt;
#endif  // LANG_CXX11
</pre>

<h2 id="Scoping">Область видимости</h2>

<h3 id="Namespaces">Простаранство имён</h3>

<p>Размещаёте свой код в пространстве имён (за некоторыми исключениями). Пространство имён должно
 иметь уникальное имя, формируемое на основе названия проекта, и, возможно, пути.
 Не используйте директиву <i>using</i> (например, <code>using namespace foo</code>). Не используйте
 встроенные (inline) пространства имён. Для безымянных пространств смотрите 
 <a href="#Unnamed_Namespaces_and_Static_Variables">Unnamed Namespaces and
Static Variables</a>.

</p><p class="definition"></p>
<p>Простанства имён делят глобальную область видимости на отдельные именованные области позволяя
 избежать совпадения (коллизий) имён.</p>

<p class="pros"></p>

<p>Простанства имён позволяют избежать конфликта имён в больших программах, при этом сами имена
 остаются достаточно короткими.</p>

<p>Например, если два разных проекта содержат класс <code>Foo</code> в глобальной области видимости,
 имена могут конфликтовать. Если каждый проект размещает код в своё пространство имён, то
 <code>project1::Foo</code> и <code>project2::Foo</code> будут разными именами, конфликтов не будет,
 в то же время код каждого проекта будет использовать <code>Foo</code> без префикса.</p>

<p>Встроенные (inline) пространства имён автоматически делают видимыми свои имена для включающего
 пространства имён. Inline namespaces automatically place their names in
the enclosing scope. Consider the following snippet, for
example:</p>

<pre class="neutralcode">namespace outer {
inline namespace inner {
  void foo();
}  // namespace inner
}  // namespace outer
</pre>

<p>The expressions <code>outer::inner::foo()</code> and
<code>outer::foo()</code> are interchangeable. Inline
namespaces are primarily intended for ABI compatibility
across versions.</p>

<p class="cons"></p>

<p>Namespaces can be confusing, because they complicate
the mechanics of figuring out what definition a name refers
to.</p>

<p>Inline namespaces, in particular, can be confusing
because names aren't actually restricted to the namespace
where they are declared. They are only useful as part of
some larger versioning policy.</p>

<p>In some contexts, it's necessary to repeatedly refer to
symbols by their fully-qualified names. For deeply-nested
namespaces, this can add a lot of clutter.</p>

<p class="decision"></p>

<p>Namespaces should be used as follows:</p>

<ul>
  <li>Follow the rules on <a href="#Namespace_Names">Namespace Names</a>.
  </li><li>Terminate namespaces with comments as shown in the given examples.
  </li><li>

  <p>Namespaces wrap the entire source file after
  includes,
  <a href="https://gflags.github.io/gflags/">
  gflags</a> definitions/declarations
  and forward declarations of classes from other namespaces.</p>

<pre>// In the .h file
namespace mynamespace {

// All declarations are within the namespace scope.
// Notice the lack of indentation.
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
</pre>

<pre>// In the .cc file
namespace mynamespace {

// Definition of functions is within scope of the namespace.
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace
</pre>

  <p>More complex <code>.cc</code> files might have additional details,
  like flags or using-declarations.</p>

<pre>#include "a.h"

ABSL_FLAG(bool, someflag, false, "dummy flag");

namespace mynamespace {

using ::foo::Bar;

...code for mynamespace...    // Code goes against the left margin.

}  // namespace mynamespace
</pre>
  </li>

  <li>To place generated protocol
  message code in a namespace, use the
  <code>package</code> specifier in the
  <code>.proto</code> file. See


  <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package">
  Protocol Buffer Packages</a>
  for details.</li>

  <li>Do not declare anything in namespace
  <code>std</code>, including forward declarations of
  standard library classes. Declaring entities in
  namespace <code>std</code> is undefined behavior, i.e.,
  not portable. To declare entities from the standard
  library, include the appropriate header file.</li>

  <li><p>You may not use a <i>using-directive</i>
  to make all names from a namespace available.</p>

<pre class="badcode">// Forbidden -- This pollutes the namespace.
using namespace foo;
</pre>
  </li>

  <li><p>Do not use <i>Namespace aliases</i> at namespace scope
  in header files except in explicitly marked
  internal-only namespaces, because anything imported into a namespace
  in a header file becomes part of the public
  API exported by that file.</p>

<pre>// Shorten access to some commonly used names in .cc files.
namespace baz = ::foo::bar::baz;
</pre>

<pre>// Shorten access to some commonly used names (in a .h file).
namespace librarian {
namespace impl {  // Internal, not part of the API.
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
  // namespace alias local to a function (or method).
  namespace baz = ::foo::bar::baz;
  ...
}
}  // namespace librarian
</pre>

  </li><li>Do not use inline namespaces.</li>
</ul>

<h3 id="Unnamed_Namespaces_and_Static_Variables">Unnamed Namespaces and Static
Variables</h3>

<p>When definitions in a <code>.cc</code> file do not need to be
referenced outside that file, place them in an unnamed
namespace or declare them <code>static</code>. Do not use either
of these constructs in <code>.h</code> files.

</p><p class="definition"></p>
<p>All declarations can be given internal linkage by placing them in unnamed
namespaces. Functions and variables can also be given internal linkage by
declaring them <code>static</code>. This means that anything you're declaring
can't be accessed from another file. If a different file declares something with
the same name, then the two entities are completely independent.</p>

<p class="decision"></p>

<p>Use of internal linkage in <code>.cc</code> files is encouraged
for all code that does not need to be referenced elsewhere.
Do not use internal linkage in <code>.h</code> files.</p>

<p>Format unnamed namespaces like named namespaces. In the
  terminating comment, leave the namespace name empty:</p>

<pre>namespace {
...
}  // namespace
</pre>

<h3 id="Nonmember,_Static_Member,_and_Global_Functions">Nonmember, Static Member, and Global Functions</h3>

<p>Prefer placing nonmember functions in a namespace; use completely global
functions rarely. Do not use a class simply to group static functions. Static
methods of a class should generally be closely related to instances of the
class or the class's static data.</p>


<p class="pros"></p>
<p>Nonmember and static member functions can be useful in
some situations. Putting nonmember functions in a
namespace avoids polluting the global namespace.</p>

<p class="cons"></p>
<p>Nonmember and static member functions may make more sense
as members of a new class, especially if they access
external resources or have significant dependencies.</p>

<p class="decision"></p>
<p>Sometimes it is useful to define a
function not bound to a class instance. Such a function
can be either a static member or a nonmember function.
Nonmember functions should not depend on external
variables, and should nearly always exist in a namespace.
Do not create classes only to group static member functions;
this is no different than just giving the function names a
common prefix, and such grouping is usually unnecessary anyway.</p>

<p>If you define a nonmember function and it is only
needed in its <code>.cc</code> file, use
<a href="#Unnamed_Namespaces_and_Static_Variables">internal linkage</a> to limit
its scope.</p>

<h3 id="Local_Variables">Local Variables</h3>

<p>Place a function's variables in the narrowest scope
possible, and initialize variables in the declaration.</p>

<p>C++ allows you to declare variables anywhere in a
function. We encourage you to declare them in as local a
scope as possible, and as close to the first use as
possible. This makes it easier for the reader to find the
declaration and see what type the variable is and what it
was initialized to. In particular, initialization should
be used instead of declaration and assignment, e.g.:</p>

<pre class="badcode">int i;
i = f();      // Bad -- initialization separate from declaration.
</pre>

<pre>int j = g();  // Good -- declaration has initialization.
</pre>

<pre class="badcode">std::vector&lt;int&gt; v;
v.push_back(1);  // Prefer initializing using brace initialization.
v.push_back(2);
</pre>

<pre>std::vector&lt;int&gt; v = {1, 2};  // Good -- v starts initialized.
</pre>

<p>Variables needed for <code>if</code>, <code>while</code>
and <code>for</code> statements should normally be declared
within those statements, so that such variables are confined
to those scopes.  E.g.:</p>

<pre>while (const char* p = strchr(str, '/')) str = p + 1;
</pre>

<p>There is one caveat: if the variable is an object, its
constructor is invoked every time it enters scope and is
created, and its destructor is invoked every time it goes
out of scope.</p>

<pre class="badcode">// Inefficient implementation:
for (int i = 0; i &lt; 1000000; ++i) {
  Foo f;  // My ctor and dtor get called 1000000 times each.
  f.DoSomething(i);
}
</pre>

<p>It may be more efficient to declare such a variable
used in a loop outside that loop:</p>

<pre>Foo f;  // My ctor and dtor get called once each.
for (int i = 0; i &lt; 1000000; ++i) {
  f.DoSomething(i);
}
</pre>

<h3 id="Static_and_Global_Variables">Static and Global Variables</h3>

<p>Objects with
<a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
static storage duration</a> are forbidden unless they are
<a href="http://en.cppreference.com/w/cpp/types/is_destructible">trivially
destructible</a>. Informally this means that the destructor does not do
anything, even taking member and base destructors into account. More formally it
means that the type has no user-defined or virtual destructor and that all bases
and non-static members are trivially destructible.
Static function-local variables may use dynamic initialization.
Use of dynamic initialization for static class member variables or variables at
namespace scope is discouraged, but allowed in limited circumstances; see below
for details.</p>

<p>As a rule of thumb: a global variable satisfies these requirements if its
declaration, considered in isolation, could be <code>constexpr</code>.</p>

<p class="definition"></p>
<p>Every object has a <dfn>storage duration</dfn>, which correlates with its
lifetime. Objects with static storage duration live from the point of their
initialization until the end of the program. Such objects appear as variables at
namespace scope ("global variables"), as static data members of classes, or as
function-local variables that are declared with the <code>static</code>
specifier. Function-local static variables are initialized when control first
passes through their declaration; all other objects with static storage duration
are initialized as part of program start-up. All objects with static storage
duration are destroyed at program exit (which happens before unjoined threads
are terminated).</p>

<p>Initialization may be <dfn>dynamic</dfn>, which means that something
non-trivial happens during initialization. (For example, consider a constructor
that allocates memory, or a variable that is initialized with the current
process ID.) The other kind of initialization is <dfn>static</dfn>
initialization. The two aren't quite opposites, though: static
initialization <em>always</em> happens to objects with static storage duration
(initializing the object either to a given constant or to a representation
consisting of all bytes set to zero), whereas dynamic initialization happens
after that, if required.</p>

<p class="pros"></p>
<p>Global and static variables are very useful for a large number of
applications: named constants, auxiliary data structures internal to some
translation unit, command-line flags, logging, registration mechanisms,
background infrastructure, etc.</p>

<p class="cons"></p>
<p>Global and static variables that use dynamic initialization or have
non-trivial destructors create complexity that can easily lead to hard-to-find
bugs. Dynamic initialization is not ordered across translation units, and
neither is destruction (except that destruction
happens in reverse order of initialization). When one initialization refers to
another variable with static storage duration, it is possible that this causes
an object to be accessed before its lifetime has begun (or after its lifetime
has ended). Moreover, when a program starts threads that are not joined at exit,
those threads may attempt to access objects after their lifetime has ended if
their destructor has already run.</p>

<p class="decision"></p>
<h4>Decision on destruction</h4>

<p>When destructors are trivial, their execution is not subject to ordering at
all (they are effectively not "run"); otherwise we are exposed to the risk of
accessing objects after the end of their lifetime. Therefore, we only allow
objects with static storage duration if they are trivially destructible.
Fundamental types (like pointers and <code>int</code>) are trivially
destructible, as are arrays of trivially destructible types. Note that
variables marked with <code>constexpr</code> are trivially destructible.</p>
<pre>const int kNum = 10;  // allowed

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // allowed

void foo() {
  static const char* const kMessages[] = {"hello", "world"};  // allowed
}

// allowed: constexpr guarantees trivial destructor
constexpr std::array&lt;int, 3&gt; kArray = {{1, 2, 3}};</pre>
<pre class="badcode">// bad: non-trivial destructor
const std::string kFoo = "foo";

// bad for the same reason, even though kBar is a reference (the
// rule also applies to lifetime-extended temporary objects)
const std::string&amp; kBar = StrCat("a", "b", "c");

void bar() {
  // bad: non-trivial destructor
  static std::map&lt;int, int&gt; kData = {{1, 0}, {2, 0}, {3, 0}};
}</pre>

<p>Note that references are not objects, and thus they are not subject to the
constraints on destructibility. The constraint on dynamic initialization still
applies, though. In particular, a function-local static reference of the form
<code>static T&amp; t = *new T;</code> is allowed.</p>

<h4>Decision on initialization</h4>

<p>Initialization is a more complex topic. This is because we must not only
consider whether class constructors execute, but we must also consider the
evaluation of the initializer:</p>
<pre class="neutralcode">int n = 5;    // fine
int m = f();  // ? (depends on f)
Foo x;        // ? (depends on Foo::Foo)
Bar y = g();  // ? (depends on g and on Bar::Bar)
</pre>

<p>All but the first statement expose us to indeterminate initialization
ordering.</p>

<p>The concept we are looking for is called <em>constant initialization</em> in
the formal language of the C++ standard. It means that the initializing
expression is a constant expression, and if the object is initialized by a
constructor call, then the constructor must be specified as
<code>constexpr</code>, too:</p>
<pre>struct Foo { constexpr Foo(int) {} };

int n = 5;  // fine, 5 is a constant expression
Foo x(2);   // fine, 2 is a constant expression and the chosen constructor is constexpr
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // fine</pre>

<p>Constant initialization is always allowed. Constant initialization of
static storage duration variables should be marked with <code>constexpr</code>
or where possible the


<a href="https://github.com/abseil/abseil-cpp/blob/03c1513538584f4a04d666be5eb469e3979febba/absl/base/attributes.h#L540">
<code>ABSL_CONST_INIT</code></a>
attribute. Any non-local static storage
duration variable that is not so marked should be presumed to have
dynamic initialization, and reviewed very carefully.</p>

<p>By contrast, the following initializations are problematic:</p>

<pre class="badcode">// Some declarations used below.
time_t time(time_t*);      // not constexpr!
int f();                   // not constexpr!
struct Bar { Bar() {} };

// Problematic initializations.
time_t m = time(nullptr);  // initializing expression not a constant expression
Foo y(f());                // ditto
Bar b;                     // chosen constructor Bar::Bar() not constexpr</pre>

<p>Dynamic initialization of nonlocal variables is discouraged, and in general
it is forbidden. However, we do permit it if no aspect of the program depends
on the sequencing of this initialization with respect to all other
initializations. Under those restrictions, the ordering of the initialization
does not make an observable difference. For example:</p>
<pre>int p = getpid();  // allowed, as long as no other static variable
                   // uses p in its own initialization</pre>

<p>Dynamic initialization of static local variables is allowed (and common).</p>



<h4>Common patterns</h4>

<ul>
  <li>Global strings: if you require a global or static string constant,
    consider using a simple character array, or a char pointer to the first
    element of a string literal. String literals have static storage duration
    already and are usually sufficient.</li>
  <li>Maps, sets, and other dynamic containers: if you require a static, fixed
    collection, such as a set to search against or a lookup table, you cannot
    use the dynamic containers from the standard library as a static variable,
    since they have non-trivial destructors. Instead, consider a simple array of
    trivial types, e.g. an array of arrays of ints (for a "map from int to
    int"), or an array of pairs (e.g. pairs of <code>int</code> and <code>const
    char*</code>). For small collections, linear search is entirely sufficient
    (and efficient, due to memory locality); consider using the facilities from

    <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/algorithm/container.h">absl/algorithm/container.h</a>


    for the standard operations. If necessary, keep the collection in sorted
    order and use a binary search algorithm. If you do really prefer a dynamic
    container from the standard library, consider using a function-local static
    pointer, as described below.</li>
  <li>Smart pointers (<code>unique_ptr</code>, <code>shared_ptr</code>): smart
    pointers execute cleanup during destruction and are therefore forbidden.
    Consider whether your use case fits into one of the other patterns described
    in this section. One simple solution is to use a plain pointer to a
    dynamically allocated object and never delete it (see last item).</li>
  <li>Static variables of custom types: if you require static, constant data of
    a type that you need to define yourself, give the type a trivial destructor
    and a <code>constexpr</code> constructor.</li>
  <li>If all else fails, you can create an object dynamically and never delete
    it by using a function-local static pointer or reference (e.g. <code>static
    const auto&amp; impl = *new T(args...);</code>).</li>
</ul>

<h3 id="thread_local">thread_local Variables</h3>

<p><code>thread_local</code> variables that aren't declared inside a function
must be initialized with a true compile-time constant,
and this must be enforced by using the


<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h">
<code>ABSL_CONST_INIT</code></a>
attribute. Prefer
<code>thread_local</code> over other ways of defining thread-local data.</p>

<p class="definition"></p>
<p>Starting with C++11, variables can be declared with the
<code>thread_local</code> specifier:</p>
<pre>thread_local Foo foo = ...;
</pre>
<p>Such a variable is actually a collection of objects, so that when different
threads access it, they are actually accessing different objects.
<code>thread_local</code> variables are much like
<a href="#Static_and_Global_Variables">static storage duration variables</a>
in many respects. For instance, they can be declared at namespace scope,
inside functions, or as static class members, but not as ordinary class
members.</p>

<p><code>thread_local</code> variable instances are initialized much like
static variables, except that they must be initialized separately for each
thread, rather than once at program startup. This means that
<code>thread_local</code> variables declared within a function are safe, but
other <code>thread_local</code> variables are subject to the same
initialization-order issues as static variables (and more besides).</p>

<p><code>thread_local</code> variable instances are destroyed when their thread
terminates, so they do not have the destruction-order issues of static
variables.</p>

<p class="pros"></p>
<ul>
  <li>Thread-local data is inherently safe from races (because only one thread
    can ordinarily access it), which makes <code>thread_local</code> useful for
    concurrent programming.</li>
  <li><code>thread_local</code> is the only standard-supported way of creating
    thread-local data.</li>
</ul>

<p class="cons"></p>
<ul>
  <li>Accessing a <code>thread_local</code> variable may trigger execution of
    an unpredictable and uncontrollable amount of other code.</li>
  <li><code>thread_local</code> variables are effectively global variables,
    and have all the drawbacks of global variables other than lack of
    thread-safety.</li>
  <li>The memory consumed by a <code>thread_local</code> variable scales with
    the number of running threads (in the worst case), which can be quite large
    in a  program.</li>
  <li>An ordinary class member cannot be <code>thread_local</code>.</li>
  <li><code>thread_local</code> may not be as efficient as certain compiler
    intrinsics.</li>
</ul>

<p class="decision"></p>
  <p><code>thread_local</code> variables inside a function have no safety
    concerns, so they can be used without restriction. Note that you can use
    a function-scope <code>thread_local</code> to simulate a class- or
    namespace-scope <code>thread_local</code> by defining a function or
    static method that exposes it:</p>

<pre>Foo&amp; MyThreadLocalFoo() {
  thread_local Foo result = ComplicatedInitialization();
  return result;
}
</pre>

<p><code>thread_local</code> variables at class or namespace scope must be
initialized with a true compile-time constant (i.e. they must have no
dynamic initialization). To enforce this, <code>thread_local</code> variables
at class or namespace scope must be annotated with


<a href="https://github.com/abseil/abseil-cpp/blob/master/absl/base/attributes.h">
<code>ABSL_CONST_INIT</code></a>
(or <code>constexpr</code>, but that should be rare):</p>

<pre>ABSL_CONST_INIT thread_local Foo foo = ...;
</pre>

<p><code>thread_local</code> should be preferred over other mechanisms for
defining thread-local data.</p>

<h2 id="Classes">Классы</h2>

<p>Классы являются основным строительным блоком в C++. И, конечно же, используются
 они часто. В этой секции описаны основные правила и запреты, которым нужно
 следовать при использовании классов.</p>

<h3 id="Doing_Work_in_Constructors">Код в конструкторе</h3>

<p>Не вызывайте виртуальные методы в конструкторе.
 Избегайте инициализации, которая может завершиться ошибкой
 (а способа сигнализировать об ошибке не предусмотрено. Прим.:
 учтите, что Гугл не любит исключения).</p>

<p class="definition"></p>
<p>Вообще в конструкторе можно выполнять любые инициализации (т.е. всю
 инициализацию сделать в конструкторе).</p>

<p class="pros"></p>
<ul>
  <li>Не нужно беспокоиться об неинициализированном классе.</li>

  <li>Объекты, которые полностью инициализируются в конструкторе,
  могут быть константными (<code>const</code>) и также их легче 
  использовать в стандартных контейнерах и алгоритмах.</li>
</ul>

<p class="cons"></p>
<ul>
  <li>Если в конструкторе вызываются виртуальные функции,
  то не вызываются реализации из производного класса. Даже если
  сейчас класс не имеет потомков, в будущем это может обернуться
  проблемой.</li>

  <li>Нет простого способа проинформировать об ошибке без 
  крэша программы (что не всегда допустимо) или выбрасывания
  исключений (которые <a href="#Exceptions">запрещены</a>).</li>

  <li>Если возникла ошибка, то у нас есть частично (обычно - неправильно)
  инициализированный объект. Очевидное действие: добавить механизм проверки
  состояния <code>bool IsValid()</code>. Однако про эту проверку легко забыть.</li>

  <li>Вы не можете пользоваться адресом конструктора. Поэтому нет, например,
  простого способа передать выполнение конструктора в другой поток.</li>
</ul>

<p class="decision"></p>
<p>Конструкторы не должны вызывать виртуальные функции. В ряде случаев
 (если это позволительно) обработка ошибок конструирования возможна
 через завершение программы. В иных случаях рассмотрите паттерн Фабричный Метод
 или используйте <code>Init()</code> (подробнее здесь:
<a href="https://abseil.io/tips/42">TotW #42</a>).
  Используйте <code>Init()</code> только в случае, если у объекта есть флаги состояния, разрешающие 
  вызывать те или иные публичные функции (т.к. сложно полноценно работать с 
  частично сконструированным объектом).</p>

<h3 id="Implicit_Conversions">Неявные преобразования</h3>

<p>Не объявляейте неявные преобразования. Используйте ключевое слово <code>explicit</code>
  для операторов преобразования типа и конструкторов с одним аргументом.</p>

<p class="definition"></p>
<p>Неявные преобразования позволяют объект одного типа (<dfn>source type</dfn>) использовать
  там, где ожидается другой тип (<dfn>destination
type</dfn>), например передача аргумента типа <code>int</code> в функцию, ожидающую <code>double</code>.</p>

<p>Помимо неявных преобразований, задаваемых языком программирования, можно также определять
  свои пользовательские,
  добавляя соответствующие члены в объявление класса (как источника, так и получателя).
  Неявное преобразование на стороне источника объявляется как 
  оператор + тип получателя (например, <code>operator bool()</code>). Неявное преобразование на стороне получателя
  реализуется конструктором, принимающим тип источника как единственный аргумент (помимо аргументов со значениями по умолчанию).</p>

<p>Ключевое слово <code>explicit</code> может применяться к конструктору или к оператору преобразования
  для явного указания, что функция может применяться только при явном соответствии типов (например, после операции приведения).
   Это применяется не только для неявного преобразования, но и для списков инициализации в C++11:</p>
<pre>class Foo {
  explicit Foo(int x, double y);
  ...
};

void Func(Foo f);
</pre>
<pre class="badcode">Func({42, 3.14});  // Ошибка
</pre>
<p>
  Этот пример кода технически не является неявным преобразованием, 
  но язык трактует это как будто подразумевается <code>explicit</code>.</p>

<p class="pros"></p>
<ul>
<li>Неявные преобразования могут сделать тип более удобным в использовании,
    не требуя явного указания типа в очевидных случаях.</li>
<li>Неявные преобразования могут быть упрощённой альтернативой для перегрузки, 
    например когда одна функция с аргументом типа <code>string_view</code> применяется
    вместо отдельных версий для <code>std::string</code> и <code>const char*</code>.</li>
<li>Применение списка инициализации является компактным и понятным способом инициализации объектов.</li>
</ul>

<p class="cons"></p>
<ul>
<li>Неявные преобразования могут скрывать баги с несоответствием типов, когда
    получаемый тип не соответствует ожиданиям пользователя
    (если он вообще предополагал приведение типа).</li>

<li>Неявные преобразования могут усложнить чтение кода, особенно при наличии
    перегруженных функций: становится неясно, какой код действительно будет вызван.</li>

<li>Конструкторы с одним аргументом могут быть случайно использованы как неявное преобразование,
    даже если это не предполагалось.</li>

<li>Когда конструктор с одним аргументом не объявлен как <code>explicit</code> 
    нельзя с уверенностью сказать: то ли это такое неявное преобразование, то ли автор
    забыл ключевое слово.</li>

<li>Не всегда понятно, какой тип должен обеспечить преобразование. А если - оба,
    код становится двусмысленным.</li>

<li>Использование списка инициализации также может добавить проблем, если целевой тип задан неявно и, особенно, если 
    сам список состоит только из одного элемента.</li>
</ul>

<p class="decision"></p>
<p>Операторы преобразования типа и конструкторы с одним аргументом
должны объявляться с ключевым словом <code>explicit</code>. Есть и исключение:
конструкторы копирования и перемещения могут объявляться без <code>explicit</code>, 
т.к. они не выполняют преобразование типов. Ещё неявные преобразования могут быть
необходимы в случае классов-обёрток для других типов (в этом случае обязательно 
 запросите разрешение у вышестоящего руководства на возможность игнорирования 
 этого важного правила).</p>

<p>Конструкторы, которые нельзя вызвать с одним аргументом, можно объявлять без
<code>explicit</code>. Конструкторы, принимающие единственный 
<code>std::initializer_list</code> также должны объявляться без <code>explicit</code> 
для поддержки инициализации копированием (например, <code>MyType m = {1, 2};</code>).</p>

<h3 id="Copyable_Movable_Types">Копируемые и перемещаемые типы</h3>

<p>Открытый интерфейс класса должен явно указывать на возможность копирования и/или перемещения, 
 или наоборот всё запрещать. Поддерживайте копирование и/или перемещение, только
 если эти операции имеют смысл для вашего типа.</p>

<p class="definition"></p>
<p>Перемещаемый тип - тот, что может быть инициализирован или присвоен из временных значений.</p>

<p>Копируемый тип - может быть инициализирован или присвоен из другого объекта того же типа 
(т.е. также, как и перемещаемый), с условием, что исходный объект остаётся неизменным.
Например, <code>std::unique_ptr&lt;int&gt;</code> - это перемещаемый, но не копируемый тип
(т.к. значение исходного <code>std::unique_ptr&lt;int&gt;</code> объекта должно измениться 
при присвоении целевому объекту). <code>int</code> и <code>std::string</code> - примеры
перемещаемый типов, которые также можно копировать: для <code>int</code> операции перемещения 
и копирования одинаковые, для <code>std::string</code> операция перемещения требует меньше ресурсов, чем копирование.</p>

<p>Для пользовательских типов копирование задаётся конструктором копирования и оператором копирования.
Перемещение задаётся либо конструктором перемещения с оператором перемещения, либо (если их нет)
соответствующими функциями копирования.</p>

<p>Конструкторы копирования и перемещения могут неявно вызываться компилятором, например 
при передаче объектов по значению.</p>

<p class="pros"></p>
<p>Объекты копируемых и перемещаемых типов могут быть переданы и получены
 по значению, что делает API проще, безопаснее, универсальнее. В этом случает нет проблем с
 владением объекта, его жизненным циклом, изменением значения и т.п., а также
 не требуется указывать их в "контракте" (всё это в отличие от
 передачи объектов по указателю или ссылке). Также предотвращается отложенное 
 взаимодействие между клиентом и реализацией, что существенно облегчает понимание и 
 поддержку кода, а также его оптимизацию компилятором. Такие объекты
 могут использоваться как аргументы других классов, требующих передачу по значению,
 (например, большинство контейнеров), и вообще они гибче (например, при использовании в
 паттернах проектирования).</p>

<p>Конструкторы копирования/перемещения и соответствующие операторы присваивания
 обычно легче определить, чем альтернативы наподобие <code>Clone()</code>, 
 <code>CopyFrom()</code> или <code>Swap()</code>, т.к. компилятор может сгенерировать
 требуемые функции (неявно или посредством <code>= default</code>). Они (функции)
 легко объявляются и можно быть уверенным, что все члены класса будут скопированы.
 Конструкторы (копирования и перемещения) в целом более эффективны, т.к. не требуют
 выделения памяти, отдельной инициализации, дополнительных присвоений, хорошо оптимизируются
 (см. <a href="http://en.cppreference.com/w/cpp/language/copy_elision">
copy elision</a>).</p>

<p>Операторы перемещения позволяют эффективно (и неявно) управлять ресурсами rvalue объектов.
 Иногда это упрощает кодирование.</p>

<p class="cons"></p>
<p>Некоторым типам не требуется быть копируемыми, и поддержка операций копирования
 может противоречить логике или привести к некорректной работе. Типы для
 синглтонов (<code>Registerer</code>), объекты для очистки (например, 
 при выходе за область видимости) (<code>Cleanup</code>) или содержащие уникальные
 данные (<code>Mutex</code>) по своему смыслу являются некопируемыми.
 Также, операции копирования для базовых классов, имеющих наследников, могут могут привести
 к "нарезке объекта" <a href="https://en.wikipedia.org/wiki/Object_slicing">object slicing</a>.
 Операции копирования по умолчанию (или неаккуратно написаные) могут привести ошибкам, которые
 тяжело обнаружить.</p>

<p>Конструкторы копирования вызываются неявно и это легко упустить из виду (особенно для
 программистов, которые раньше писали на языках, где передача объектов производится по ссылке).
 Также можно снизить производительность, делая лишние копирования.</p>

<p class="decision"></p>

<p>Открытый интерфейс каждого класса должен явно указывать, какие операции копирования и/или
 перемещения он поддерживает. Обычно это делается в секции public в виде явных деклараций 
 нужных функций или объявлением их как delete.</p>

<p>В частности, копирумый класс должен явно объявлять операции копирования; только перемещаемый
 класс должен явно объявить операции перемещения; некопируемый/неперемещаемый класс должен явно
 запретить (<code>= delete</code>) операции копирования. Явная декларация или удаление всех 
 четырёх функций копирования и перемещения также допустима, хотя это и не требуется. Если вы 
 реализуете оператор копирования и/или перемещения, то необходимо также сделать соответствующий
 конструктор.</p>

<pre>class Copyable {
 public:
  Copyable(const Copyable&amp; other) = default;
  Copyable&amp; operator=(const Copyable&amp; other) = default;

  // Неявное определение операций перемещения будет запрещено (т.к. объявлено копирование)
};

class MoveOnly {
 public:
  MoveOnly(MoveOnly&amp;&amp; other);
  MoveOnly&amp; operator=(MoveOnly&amp;&amp; other);

  // Неявно определённые операции копирования удаляются. Но (если хотите) можно это записать явно:
  MoveOnly(const MoveOnly&amp;) = delete;
  MoveOnly&amp; operator=(const MoveOnly&amp;) = delete;
};

class NotCopyableOrMovable {
 public:
  // Такое объявление запрещает и копирование и перемещение
  NotCopyableOrMovable(const NotCopyableOrMovable&amp;) = delete;
  NotCopyableOrMovable&amp; operator=(const NotCopyableOrMovable&amp;)
      = delete;

  // Хотя операции перемещения запрещены (неявно), можно записать это явно:
  NotCopyableOrMovable(NotCopyableOrMovable&amp;&amp;) = delete;
  NotCopyableOrMovable&amp; operator=(NotCopyableOrMovable&amp;&amp;)
      = delete;
};
</pre>

<p>Описываемые объявления или удаления функций можно опустить в очевидных случаях:
</p><ul>
<li>Если класс не содержит секции <code>private</code> (например, структура 
    <a href="#Structs_vs._Classes">struct</a> или класс-интерфейс), то 
    копируемость и перемещаемость можно заявить через аналогичное свойство 
    любого открытого члена.
</li><li>Если базовый класс явно некопируемый и неперемещаемый, наследные классы
    будут такими же. Однако, если базовый класс не объявляет это операции,
    то этого будет недостаточно для прояснения свойств наследуемых классов.
</li><li>Заметим, что если (например) конструктор копирования объявлен/удалён,
    то нужно и явно объявить/удалить оператор копирования (т.к. его статус неочевиден).
    Аналогично и для объявления/удаления оператора копирования. Аналогично и для операций
    перемещения.
</li></ul>

<p>Тип не следует объявлять копируемым/перемещаемым, если для обычного программиста
 не понятна необходимость этих операций или если операции очень требовательны к ресурсам и 
 производительности. Операции перемещения для копируемых типов это всегда
 оптимизация производительности, но с другой стороны - это потенциальный источник багов и 
 усложнений. Поэтому не объявляйте операции перемещения, если они не дают значительного
 выигрыша по производительности по сравнению с копированием. Вообще желательно (если для класса
 заявляются операции копирования) всё спроектировать так, чтобы использовались
 функции копирования по-умолчанию. И обязательно проверьте корректность работы
 любых операций по-умолчанию.</p>

<p>Из-за риска "слайсинга" предпочтительным будет избегать открытых операторов 
 копирования и перемещения для классов, которые планируется использовать в качестве 
 базовых (и предпочтительно не наследоваться от класса с такими функциями). Если же 
 необходимо сделать базовый класс копируемым, то сделайте открытую виртуальную 
 функцию <code>Clone()</code> и защищённый (protected) конструктор копий с тем, чтобы 
 производный класс мог их использовать для реализации операций копирования.</p>

<h3 id="Structs_vs._Classes">Структуры vs Классы</h3>

<p>Используйте структуры (<code>struct</code>) только для пассивных объектов, хранящих
 данные. В других случаях используйте классы (<code>class</code>).</p>

<p>Ключевые слова <code>struct</code> и <code>class</code>
 практически идентичны в C++. Однако, у нас есть собственное понимание
 для каждого ключевого слова, поэтому используйте то, которое подходит по
 назначению и смыслу.</p>

<p>Структуры должны использоваться для пассивных объектов, только для
 переноса данных. Они могут иметь собственные константы, однако не должно 
 быть никакой функциональности (за, возможно, исключением функций get/set).
 Все поля должны быть открытыми (public), доступны для прямого доступа
 и это более предпочтительно, чем использование функций get/set. Структуры 
 не должны содержать инварианты (например,
 вычисленные значения), которые основаны на зависимости между различными 
 полями структуры: возможность напрямую изменять поля может сделать
 инвариант невалидным. Методы не должны ограничивать использование структуры, но 
 могут присваивать значения полям: т.е. как конструктор, деструктор или функции
 <code>Initialize()</code>, <code>Reset()</code>.</p>

<p>Если требуется дополнительная функциональность в обработке данных или инварианты,
 то предпочтительно применение классов (<code>class</code>). Также, если сомневаетесь, 
 что выбрать - используйте классы.</p>

<p>В ряде случаев (<a href="#Template_metaprogramming">шаблонные мета-функции</a>,
 traits, некоторые функторы) для единообразия с STL допускается использование структур вместо классов.</p>

<p>Не забудьте, что переменные в структурах и классах <a href="#Variable_Names">именуются</a> 
 разными стилями.</p>

<h3 id="Structs_vs._Tuples">Структуры vs пары (pair) и кортежи (tuple)</h3>

<p>Если отдельные элементы в блоке данных могут осмысленно называться, то желательно использовать
 структуры вместо пар или кортежей.</p>

<p>
  Хотя использование пар и кортежей позволяет не изобретать велосипед с собственным типом
  и сэкономит много времени при <em>написании</em> кода, поля с осмысленными именами (вместо
  <code>.first</code>, <code>.second</code> или <code>std::get&lt;X&gt;</code>) будут
  более понятны при <em>чтении</em> кода. И хотя C++14 для кортежей в дополнение к доступу по индексу 
  добавляется доступ по типу (<code>std::get&lt;Type&gt;</code>, а тип должен быть
  уникальным), имя поля намного более информативно нежели тип.</p>

<p>
  Пары и кортежи являются подходящими в коде, где нет специального различия между
  элементами пары или кортежа. Также они требуются для работы с существующим кодом или API.</p>

<h3 id="Inheritance">Наследование</h3>

<p>Часто композиция класса более подходяща, чем наследование. Когда используйте наследование,
делайте его открытым (<code>public</code>).</p>

<p class="definition"></p>
<p>Когда дочерний класс наследуется от базового, он включает определения всех данных
 и операций от базового. "Наследование интерфейса" - это наследование от
 чистого абстрактного базового класса (в нём не определены состояние или методы). Всё остальное
 - это "наследование реализации".</p>

<p class="pros"></p>
<p>Наследование реализации уменьшает размер кода благодаря повторному использованию
 частей базового класса (который становится частью нового класса). Т.к. наследование является декларацией времени компиляции, это
 позволяет компилятору понимать структуру и находить ошибки. Наследование интерфейса может быть 
 использовано чтобы класс поддерживал требуемый API. И также, компилятор может находить
 ошибки, если класс не определяет требуемый метод наследуемого API.</p>

<p class="cons"></p>
<p>В случае наследования реализации, код начинает размазываться между базовым и дочерним классом и
 это может усложнить понимание кода. Также, дочерний класс не может переопределять код невиртуальных
 функций (не может менять их реализацию).</p>

<p>Множественное наследование ещё более проблемное, а также иногда приводит к уменьшению производительности.
 Часто просадка производительности при переходе от одиночного наследования к множественному
 может быть больше, чем переход от обычных функций к виртуальным. Также от множественного наследования
 один шаг до ромбического, а это уже ведёт к неопределённости, путанице и, конечно же, багам.</p>

<p class="decision"></p>

<p>Любое наследование должно быть открытым (<code>public</code>). Если хочется сделать 
 закрытое (<code>private</code>), то лучше добавить новый член с экземпляром базового класса.</p>

<p>Не злоупотребляйте наследованием реализации. Композиция классов часто более предпочтительна.
 Попытайтесь ограничить использование наследования семантикой "Является": <code>Bar</code> можно наследовать
 от <code>Foo</code>, если можно сказать, что <code>Bar</code> "Является" <code>Foo</code> (т.е. там,
 где используется <code>Foo</code>, можно также использовать и <code>Bar</code>).</p>

<p>Защищёнными (<code>protected</code>) делайте лишь те функции, которые должны быть доступны 
 для дочерних классов. Заметьте, что <a href="#Access_Control">данные должны быть закрытыми</a> (private).</p>

<p>Явно декларируйте переопределение виртуальных функций/деструктора с помошью спецификаторов: либо 
 <code>override</code>, либо (если требуется) <code>final</code>. Не используйте спецификатор
 <code>virtual</code> при переопределении функций. Объяснение: функция или деструктор, помеченные
 <code>override</code> или <code>final</code>, но не являющиеся виртуальными просто не 
 скомпилируются (что помогает обнаружить общие ошибки). Также спецификаторы работают как
 документация; а если спецификаторов нет, то программист будет вынужден проверить всю иерархию, чтобы
 уточнить виртуальность функции.</p>

<p>Множественное наследование допустимо, однако множественное наследование <em>реализации</em>
 не рекомендуется от слова совсем.</p>

<h3 id="Operator_Overloading">Перегрузка операторов</h3>

<p>Перегружайте операторы в рамках разумного. Не используйте пользовательские литералы.</p>

<p class="definition"></p>
<p>C++ позволяет пользовательскому коду 
<a href="http://en.cppreference.com/w/cpp/language/operators">переопределять 
 встроенные операторы</a> используя ключевое слово 
 <code>operator</code> и пользовательский типа как один из параметров; 
 также <code>operator</code> позволяет определять новые литералы, используя 
 <code>operator""</code>; также можно создавать функции приведения типов, наподобие
 <code>operator bool()</code>.</p>

<p class="pros"></p>
<p>Использование перегрузки операторов для пользовательских типов
 (по аналогии со встроенными типами) может сделать код более сжатым и интуитивным.
 Перегружаемые операторы соответствуют определённым операциям
 (например, <code>==</code>, <code>&lt;</code>,
 <code>=</code> и <code>&lt;&lt;</code>) и если код следует логике применения
 этих операций, то пользовательские типы можно сделать понятнее и использовать
 при работе с внешними библиотеками, которые опираются на эти операции.</p>

<p>Пользовательские литералы - очень эффективный способ для создания пользовательских
 объектов.</p>

<p class="cons"></p>
<ul>
  <li>Написать комплект операторов для класса (корректных, согласованных и
  логичных) - это может потребовать известных усилий и, при недоработанном коде, 
  это может обернуться труднопонимаемыми багами.</li>

  <li>Излишняя перегрузка операторов может усложнить понимание кода, особенно если
  код не соответствует логике операции.</li>

  <li>Все недостатки, связанные с перегрузкой функций, присущи и перегрузке 
  операторов.</li>

  <li>Перегрузка операторов обмануть других программистов, ожидающих 
  простую и быструю встроенную операцию, а получающие нечто ресурсоёмкое.</li>

  <li>Поиск мест вызова перегруженных операторов может быть нетривиальной
  задачей, и это явно сложнее обычного текстового поиска.</li>

  <li>При ошибках в типах аргументов вы можете вместо сообщений об ошибке/предупреждении 
  от компилятора (по которым легко найти проблему и исправить её), 
  получить "корректный" вызов другого оператора. Например, 
  код для <code>foo &lt; bar</code> может сильно отличаться от кода
  для <code>&amp;foo &lt; &amp;bar</code>; немного напутав в типах получим ошибочный вызов.</li>

  <li>Перегрузка некоторых операторов является в принципе рискованным занятием.
  Перегрузка унарного <code>&amp;</code> может привести к тому, что один и тот же код
  будет трактоваться по разному в зависимости от видимости декларации этой перегрузки.
  Перегрузка операторов <code>&amp;&amp;</code>, <code>||</code> и <code>,</code>
  (запятая) может поменять порядок (и правила) вычисления выражений.</li>

  <li>Часто операторы определяются вне класса, и есть риск использования 
  разных реализаций одного и того же оператора. Если оба определения будут 
  слинкованы в один бинарный файл, можно получить неопределённое поведение и 
  хитрые баги.</li>

  <li>Пользовательские литералы (UDL) позволяют создавать новые синтаксические формы,
  незнакомые даже продвинутым C++ программистам. Например: 
  <code>"Hello World"sv</code> как сокращение для <code>std::string_view("Hello World")</code>.
  Исходная нотация может быть более понятной, хотя и не такой компактной.</li>

  <li>Т.к. для UDL не указывается пространство имён, потребуется либо использовать
  using-директиву (которая <a href="#Namespaces">запрещена</a>) или using-декларацию
   (которая также <a href="#Aliases">запрещена (в заголовочных файлах)</a>, кроме случая
  когда импортируемые имена являются частью интерфейса, показываемого в заголовочном файле).
  Для таких заголовочных файлов лучше бы избегать суффикусов UDL, и желательно избегать
  зависимости между литералами, которые различны в заголовочном и исходном файле.</li>
</ul>

<p class="decision"></p>
<p>Определяйте перегруженные операторы только если их смысл очевиден, понятен,
 и соответствует общей логике. Например, используйте <code>|</code> в смысле
 операции ИЛИ; реализовывать же вместо этого логику канала (pipe) - не
 очень хорошая идея.</p>

<p>Определяйте операторы только для ваших собственных типов, делайте это 
 в том же самом заголовочном и исходном файле, и в том же пространстве имён.
 В результате операторы будут доступны там же, где и сами типы, а риск множественного 
 определения минимален. По возможности избегайте определения операторов 
 как шаблонов, т.к. придётся соответствовать любому набору шаблонных аргументов.
 Если вы определяете оператор, также определяйте "родственные" к нему. И позаботьтесь о
 согласованности выдаваемых ими результатов. Например, если определяется оператор
 <code>&lt;</code>, то определяйте все операторы сравнения и проследите, чтобы
 операторы <code>&lt;</code> и <code>&gt;</code> никогда не возвращали true для
 один и тех же аргументов.</p>

<p>Желательно определять неизменяющие значения бинарные операторы как
 внешние функции (не-члены). Если же бинарный оператор объявлен членом
 класса, неявное преобразование может применяться к правому аргументу, но
 не к левому. А это может слегка расстроить программистов, если (например) код 
 <code>a &lt; b</code> - будет компилироваться, а
 <code>b &lt; a</code> - нет.</p>

<p>Не нужно пытаться обойти переопределение операторов. Если требуется сравнение 
 (или присваивание и функция вывода), то лучше определить <code>==</code> 
 (или <code>=</code> и <code>&lt;&lt;</code>) вместо своих функций
 <code>Equals()</code>, <code>CopyFrom()</code> и <code>PrintTo()</code>.
 И наоборот: не нужно переопределять оператор только
 потому, что внешние библиотеки ожидают этого. Например, если тип данных
 нельзя упорядочить и хочется хранить его в <code>std::set</code>, то лучше 
 сделайте пользовательскую функцию сравнения и не пользуйтесь оператором <code>&lt;</code>.</p>

<p>Не переопределяйте <code>&amp;&amp;</code>, <code>||</code>,
 <code>,</code> (запятая) или унарный <code>&amp;</code>. Не переопределяйте 
 <code>operator""</code>, т.е. не стоит вводить собственные литералы. Не используйте
 ранее определённые литералы (включая стандартную библиотеку и не только).</p>

<p>Дополнительная информация:<br/>Преобразование типов описано в секции 
 <a href="#Implicit_Conversions">неявные преобразования</a>.
 Оператор <code>=</code> расписан в 
 <a href="#Copy_Constructors">конструкторе копий</a>. Тема перегрузки 
 <code>&lt;&lt;</code> для работы со стримами освещена в 
 <a href="#Streams">потоках/streams</a>. Также можно ознакомиться с правилами из раздела 
 <a href="#Function_Overloading">перегрузка функций</a>, которые также 
 подходят и для операторов.</p>

<h3 id="Access_Control">Доступ к членам класса</h3>

<p>Данные класса делайте всегда закрытыми <code>private</code>, кроме 
 <a href="#Constant_Names">констант</a>. Это упрощает использование инвариантов
 путём добавления простейших (часто - константных) функций доступа.</p>

<p>Допустимо объявлять данные класса как <code>protected</code> для использования
 в тестовых классах (например, при использовании
 <a href="https://github.com/google/googletest">Google Test</a>) или
 других подобных случаях.</p>

<h3 id="Declaration_Order">Порядок объявления</h3>

<p>Располагайте похожие объявления в одном месте, выносите общие части наверх.</p>

<p>Определение класса обычно начинается с секции <code>public:</code>,
 далее идёт <code>protected:</code> и затем <code>private:</code>. Пустые секции не указывайте.</p>

<p>Внутри каждой секции группируйте вместе подобные декларации.
 Предпочтителен следующий порядок: типы (включая <code>typedef</code>,
 <code>using</code>, вложенные классы и структуры),
 константы, фабричные методы, конструкторы, операторы присваивания, 
 деструкторы, остальные методы, члены данных.</p>

<p>Не размещайте в определении класса громоздкие определения методов.
 Обычно только тривиальные, очень короткие или критичные по производительности
 методы "встраиваются" в определение класса. См. также 
 <a href="#Inline_Functions">Встраиваемые функции</a>.</p>

<h2 id="Functions">Functions</h2>

<h3 id="Output_Parameters">Output Parameters</h3>

<p>The output of a C++ function is naturally provided via
a return value and sometimes via output parameters.</p>

<p>Prefer using return values over output parameters: they
improve readability, and often provide the same or better
performance.  If output-only parameters are used,
they should appear after input parameters.</p>

<p>Parameters are either input to the function, output from the
function, or both. Input parameters are usually values or
<code>const</code> references, while output and input/output
parameters will be pointers to non-<code>const</code>.</p>

<p>When ordering function parameters, put all input-only
parameters before any output parameters. In particular,
do not add new parameters to the end of the function just
because they are new; place new input-only parameters before
the output parameters.</p>

<p>This is not a hard-and-fast rule. Parameters that are
both input and output (often classes/structs) muddy the
waters, and, as always, consistency with related
functions may require you to bend the rule.</p>

<h3 id="Write_Short_Functions">Write Short Functions</h3>

<p>Prefer small and focused functions.</p>

<p>We recognize that long functions are sometimes
appropriate, so no hard limit is placed on functions
length. If a function exceeds about 40 lines, think about
whether it can be broken up without harming the structure
of the program.</p>

<p>Even if your long function works perfectly now,
someone modifying it in a few months may add new
behavior. This could result in bugs that are hard to
find. Keeping your functions short and simple makes it
easier for other people to read and modify your code.
Small functions are also easier to test.</p>

<p>You could find long and complicated functions when
working with
some code. Do not be
intimidated by modifying existing code: if working with
such a function proves to be difficult, you find that
errors are hard to debug, or you want to use a piece of
it in several different contexts, consider breaking up
the function into smaller and more manageable pieces.</p>

<h3 id="Reference_Arguments">Reference Arguments</h3>

<p>All parameters passed by lvalue reference must be labeled
<code>const</code>.</p>

<p class="definition"></p>
<p>In C, if a
function needs to modify a variable, the parameter must
use a pointer, eg <code>int foo(int *pval)</code>. In
C++, the function can alternatively declare a reference
parameter: <code>int foo(int &amp;val)</code>.</p>

<p class="pros"></p>
<p>Defining a parameter as reference avoids ugly code like
<code>(*pval)++</code>. Necessary for some applications
like copy constructors. Makes it clear, unlike with
pointers, that a null pointer is not a possible
value.</p>

<p class="cons"></p>
<p>References can be confusing, as they have value syntax
but pointer semantics.</p>

<p class="decision"></p>
<p>Within function parameter lists all references must be
<code>const</code>:</p>

<pre>void Foo(const std::string &amp;in, std::string *out);
</pre>

<p>In fact it is a very strong convention in Google code
that input arguments are values or <code>const</code>
references while output arguments are pointers. Input
parameters may be <code>const</code> pointers, but we
never allow non-<code>const</code> reference parameters
except when required by convention, e.g.,
<code>swap()</code>.</p>

<p>However, there are some instances where using
<code>const T*</code> is preferable to <code>const
T&amp;</code> for input parameters. For example:</p>

<ul>
  <li>You want to pass in a null pointer.</li>

  <li>The function saves a pointer or reference to the
  input.</li>
</ul>

<p> Remember that most of the time input
parameters are going to be specified as <code>const
T&amp;</code>. Using <code>const T*</code> instead
communicates to the reader that the input is somehow
treated differently. So if you choose <code>const
T*</code> rather than <code>const T&amp;</code>, do so
for a concrete reason; otherwise it will likely confuse
readers by making them look for an explanation that
doesn't exist.</p>

<h3 id="Function_Overloading">Function Overloading</h3>

<p>Use overloaded functions (including constructors) only if a
reader looking at a call site can get a good idea of what
is happening without having to first figure out exactly
which overload is being called.</p>

<p class="definition"></p>
<p>You may write a function that takes a <code>const
std::string&amp;</code> and overload it with another that
takes <code>const char*</code>. However, in this case consider
std::string_view
 instead.</p>

<pre>class MyClass {
 public:
  void Analyze(const std::string &amp;text);
  void Analyze(const char *text, size_t textlen);
};
</pre>

<p class="pros"></p>
<p>Overloading can make code more intuitive by allowing an
identically-named function to take different arguments.
It may be necessary for templatized code, and it can be
convenient for Visitors.</p>
<p>Overloading based on const or ref qualification may make utility
  code more usable, more efficient, or both.
  (See <a href="http://abseil.io/tips/148">TotW 148</a> for more.)
</p>

<p class="cons"></p>
<p>If a function is overloaded by the argument types alone,
a reader may have to understand C++'s complex matching
rules in order to tell what's going on. Also many people
are confused by the semantics of inheritance if a derived
class overrides only some of the variants of a
function.</p>

<p class="decision"></p>
<p>You may overload a function when there are no semantic differences
between variants. These overloads may vary in types, qualifiers, or
argument count. However, a reader of such a call must not need to know
which member of the overload set is chosen, only that <b>something</b>
from the set is being called. If you can document all entries in the
overload set with a single comment in the header, that is a good sign
that it is a well-designed overload set.</p>

<h3 id="Default_Arguments">Default Arguments</h3>

<p>Default arguments are allowed on non-virtual functions
when the default is guaranteed to always have the same
value. Follow the same restrictions as for <a href="#Function_Overloading">function overloading</a>, and
prefer overloaded functions if the readability gained with
default arguments doesn't outweigh the downsides below.</p>

<p class="pros"></p>
<p>Often you have a function that uses default values, but
occasionally you want to override the defaults. Default
parameters allow an easy way to do this without having to
define many functions for the rare exceptions. Compared
to overloading the function, default arguments have a
cleaner syntax, with less boilerplate and a clearer
distinction between 'required' and 'optional'
arguments.</p>

<p class="cons"></p>
<p>Defaulted arguments are another way to achieve the
semantics of overloaded functions, so all the <a href="#Function_Overloading">reasons not to overload
functions</a> apply.</p>

<p>The defaults for arguments in a virtual function call are
determined by the static type of the target object, and
there's no guarantee that all overrides of a given function
declare the same defaults.</p>

<p>Default parameters are re-evaluated at each call site,
which can bloat the generated code. Readers may also expect
the default's value to be fixed at the declaration instead
of varying at each call.</p>

<p>Function pointers are confusing in the presence of
default arguments, since the function signature often
doesn't match the call signature. Adding
function overloads avoids these problems.</p>

<p class="decision"></p>
<p>Default arguments are banned on virtual functions, where
they don't work properly, and in cases where the specified
default might not evaluate to the same value depending on
when it was evaluated. (For example, don't write <code>void
f(int n = counter++);</code>.)</p>

<p>In some other cases, default arguments can improve the
readability of their function declarations enough to
overcome the downsides above, so they are allowed. When in
doubt, use overloads.</p>

<h3 id="trailing_return">Trailing Return Type Syntax</h3>

<p>Use trailing return types only where using the ordinary syntax (leading
  return types) is impractical or much less readable.</p>

<p class="definition"></p>
<p>C++ allows two different forms of function declarations. In the older
  form, the return type appears before the function name. For example:</p>
<pre>int foo(int x);
</pre>
<p>The newer form, introduced in C++11, uses the <code>auto</code>
  keyword before the function name and a trailing return type after
  the argument list. For example, the declaration above could
  equivalently be written:</p>
<pre>auto foo(int x) -&gt; int;
</pre>
<p>The trailing return type is in the function's scope. This doesn't
  make a difference for a simple case like <code>int</code> but it matters
  for more complicated cases, like types declared in class scope or
  types written in terms of the function parameters.</p>

<p class="pros"></p>
<p>Trailing return types are the only way to explicitly specify the
  return type of a <a href="#Lambda_expressions">lambda expression</a>.
  In some cases the compiler is able to deduce a lambda's return type,
  but not in all cases. Even when the compiler can deduce it automatically,
  sometimes specifying it explicitly would be clearer for readers.
</p>
<p>Sometimes it's easier and more readable to specify a return type
  after the function's parameter list has already appeared. This is
  particularly true when the return type depends on template parameters.
  For example:</p>
  <pre>    template &lt;typename T, typename U&gt;
    auto add(T t, U u) -&gt; decltype(t + u);
  </pre>
    <p>versus</p>
  <pre>    template &lt;typename T, typename U&gt;
    decltype(declval&lt;T&amp;&gt;() + declval&lt;U&amp;&gt;()) add(T t, U u);
  </pre>

<p class="cons"></p>
<p>Trailing return type syntax is relatively new and it has no
  analogue in C++-like languages such as C and Java, so some readers may
  find it unfamiliar.</p>
<p>Existing code bases have an enormous number of function
  declarations that aren't going to get changed to use the new syntax,
  so the realistic choices are using the old syntax only or using a mixture
  of the two. Using a single version is better for uniformity of style.</p>

<p class="decision"></p>
<p>In most cases, continue to use the older style of function
  declaration where the return type goes before the function name.
  Use the new trailing-return-type form only in cases where it's
  required (such as lambdas) or where, by putting the type after the
  function's parameter list, it allows you to write the type in a much
  more readable way. The latter case should be rare; it's mostly an
  issue in fairly complicated template code, which is
  <a href="#Template_metaprogramming">discouraged in most cases</a>.</p>


<h2 id="Google-Specific_Magic">Google-Specific Magic</h2>



<div>
<p>There are various tricks and utilities that
we use to make C++ code more robust, and various ways we use
C++ that may differ from what you see elsewhere.</p>
</div>



<h3 id="Ownership_and_Smart_Pointers">Ownership and Smart Pointers</h3>

<p>Prefer to have single, fixed owners for dynamically
allocated objects. Prefer to transfer ownership with smart
pointers.</p>

<p class="definition"></p>
<p>"Ownership" is a bookkeeping technique for managing
dynamically allocated memory (and other resources). The
owner of a dynamically allocated object is an object or
function that is responsible for ensuring that it is
deleted when no longer needed. Ownership can sometimes be
shared, in which case the last owner is typically
responsible for deleting it. Even when ownership is not
shared, it can be transferred from one piece of code to
another.</p>

<p>"Smart" pointers are classes that act like pointers,
e.g. by overloading the <code>*</code> and
<code>-&gt;</code> operators. Some smart pointer types
can be used to automate ownership bookkeeping, to ensure
these responsibilities are met.
<a href="http://en.cppreference.com/w/cpp/memory/unique_ptr">
<code>std::unique_ptr</code></a> is a smart pointer type
introduced in C++11, which expresses exclusive ownership
of a dynamically allocated object; the object is deleted
when the <code>std::unique_ptr</code> goes out of scope.
It cannot be copied, but can be <em>moved</em> to
represent ownership transfer.
<a href="http://en.cppreference.com/w/cpp/memory/shared_ptr">
<code>std::shared_ptr</code></a> is a smart pointer type
that expresses shared ownership of
a dynamically allocated object. <code>std::shared_ptr</code>s
can be copied; ownership of the object is shared among
all copies, and the object is deleted when the last
<code>std::shared_ptr</code> is destroyed. </p>

<p class="pros"></p>
<ul>
  <li>It's virtually impossible to manage dynamically
  allocated memory without some sort of ownership
  logic.</li>

  <li>Transferring ownership of an object can be cheaper
  than copying it (if copying it is even possible).</li>

  <li>Transferring ownership can be simpler than
  'borrowing' a pointer or reference, because it reduces
  the need to coordinate the lifetime of the object
  between the two users.</li>

  <li>Smart pointers can improve readability by making
  ownership logic explicit, self-documenting, and
  unambiguous.</li>

  <li>Smart pointers can eliminate manual ownership
  bookkeeping, simplifying the code and ruling out large
  classes of errors.</li>

  <li>For const objects, shared ownership can be a simple
  and efficient alternative to deep copying.</li>
</ul>

<p class="cons"></p>
<ul>
  <li>Ownership must be represented and transferred via
  pointers (whether smart or plain). Pointer semantics
  are more complicated than value semantics, especially
  in APIs: you have to worry not just about ownership,
  but also aliasing, lifetime, and mutability, among
  other issues.</li>

  <li>The performance costs of value semantics are often
  overestimated, so the performance benefits of ownership
  transfer might not justify the readability and
  complexity costs.</li>

  <li>APIs that transfer ownership force their clients
  into a single memory management model.</li>

  <li>Code using smart pointers is less explicit about
  where the resource releases take place.</li>

  <li><code>std::unique_ptr</code> expresses ownership
  transfer using C++11's move semantics, which are
  relatively new and may confuse some programmers.</li>

  <li>Shared ownership can be a tempting alternative to
  careful ownership design, obfuscating the design of a
  system.</li>

  <li>Shared ownership requires explicit bookkeeping at
  run-time, which can be costly.</li>

  <li>In some cases (e.g. cyclic references), objects
  with shared ownership may never be deleted.</li>

  <li>Smart pointers are not perfect substitutes for
  plain pointers.</li>
</ul>

<p class="decision"></p>
<p>If dynamic allocation is necessary, prefer to keep
ownership with the code that allocated it. If other code
needs access to the object, consider passing it a copy,
or passing a pointer or reference without transferring
ownership. Prefer to use <code>std::unique_ptr</code> to
make ownership transfer explicit. For example:</p>

<pre>std::unique_ptr&lt;Foo&gt; FooFactory();
void FooConsumer(std::unique_ptr&lt;Foo&gt; ptr);
</pre>



<p>Do not design your code to use shared ownership
without a very good reason. One such reason is to avoid
expensive copy operations, but you should only do this if
the performance benefits are significant, and the
underlying object is immutable (i.e.
<code>std::shared_ptr&lt;const Foo&gt;</code>).  If you
do use shared ownership, prefer to use
<code>std::shared_ptr</code>.</p>

<p>Never use <code>std::auto_ptr</code>. Instead, use
<code>std::unique_ptr</code>.</p>

<h3 id="cpplint">cpplint</h3>

<p>Use <code>cpplint.py</code> to detect style errors.</p>

<p><code>cpplint.py</code>
is a tool that reads a source file and identifies many
style errors. It is not perfect, and has both false
positives and false negatives, but it is still a valuable
tool. False positives can be ignored by putting <code>//
NOLINT</code> at the end of the line or
<code>// NOLINTNEXTLINE</code> in the previous line.</p>



<div>
<p>Some projects have instructions on
how to run <code>cpplint.py</code> from their project
tools. If the project you are contributing to does not,
you can download
<a href="https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py">
<code>cpplint.py</code></a> separately.</p>
</div>



<h2 id="Other_C++_Features">Ещё возможности C++</h2>

<h3 id="Rvalue_references">Rvalue-ссылки</h3>

<p>Используйте rvalue-ссылки:</p>
<ul>
  <li>Для объявления конструкторов перемещения и операторов перемещения.</li>

  <li>Для объявления <a href="#Function_Overloading">перегружаемых функций</a> с 
  const&amp; и &amp;&amp; аргументами если это обеспечит значительное улучшение
  производительности против передачи по значению или если пишется код с
  небольшими накладными расходами или поддержкой произвольных типов. Избегайте 
  увеличения количества перегружаемых функций (обычно бывает, когда комбинируются
  типы для несколько параметров).</li>

  <li>Для поддержки 'perfect forwarding' в 'универсальном' коде.</li>
</ul>

<p class="definition"></p>
<p> Rvalue-ссылка является ссылочным типом, привязанным к временному объекту.
 По синтаксису похожа на обычную ссылку. Например, <code>void f(std::string&amp;&amp; s);</code>
 объявляет функцию с аргументом rvalue-ссылка на std::string.</p>

<p id="Forwarding_references">Когда суффикс '&amp;&amp;' (без дополнительных квалификаторов) используется с шаблонным аргументом
 функции, то применяются специальные правила определения типа аргумента. И такая ссылка имеет название forwarding reference.</p>

<p class="pros"></p>
<ul>
  <li>Определение конструктора перемещения (принимающего rvalue-ссылку на тип класса) даёт
  возможность переместить (move) класс вместо его копирования. Например, если <code>v1</code> это <code>std::vector&lt;std::string&gt;</code>,
  то код <code>auto v2(std::move(v1))</code> скорее всего выполнит несколько операций с указателями вместо копирования большого объёма данных.
  И в большинстве случаев это приведёт к существенному увеличению производительности кода.</li>

  <li>Rvalue-ссылки позволяют реализовать типы, которые можно перемещать, а не копировать. Это полезно для типов,
  которые нельзя копировать, но которые хочется передавать в функцию как аргумент, хранить в контейнере и т.д.</li>

  <li>Функция <code>std::move</code> необходима для эффективного использования 
  некоторых типов стандартной библиотеки, таких как <code>std::unique_ptr</code>.</li>

  <li><a href="#Forwarding_references">Forwarding references</a>, использующие объявление
  rvalue-ссылки, позволяют написать единую обёртку, перемещающую аргумент в другую функцию.
  И это одинаково работает вне зависимости от того, временный объект или нет,
  константный он или не очень. Это и называется 'perfect forwarding'.</li>
</ul>

<p class="cons"></p>
<ul>
  <li>Rvalue-ссылки не все хорошо понимают. Особенности, наподобие схлопывания ссылок или
  специальных правил определения типа, всё сильно усложняют.</li>

  <li>Rvalue-ссылки  references are often misused. Using rvalue
  references is counter-intuitive in signatures where the argument is expected
  to have a valid specified state after the function call, or where no move
  operation is performed.</li>
</ul>

<p class="decision"></p>
<p>You may use rvalue references to define move constructors and move
assignment operators (as described in
<a href="#Copyable_Movable_Types">Copyable and Movable Types</a>). See the
<a href="primer#copying_moving">C++ Primer</a> for more information about
move semantics and <code>std::move</code>.</p>

<p>You may use rvalue references to define pairs of overloads, one taking
<code>Foo&amp;&amp;</code> and the other taking <code>const Foo&amp;</code>.
Usually the preferred solution is just to pass by value, but an overloaded pair
of functions sometimes yields better performance and is sometimes necessary in
generic code that needs to support a wide variety of types. As always: if
you're writing more complicated code for the sake of performance, make sure you
have evidence that it actually helps.</p>

<p>You may use forwarding references in conjunction with <code>
<a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a></code>,
to support perfect forwarding.</p>

<h3 id="Friends">Friends</h3>

<p>We allow use of <code>friend</code> classes and functions,
within reason.</p>

<p>Friends should usually be defined in the same file so
that the reader does not have to look in another file to
find uses of the private members of a class. A common use
of <code>friend</code> is to have a
<code>FooBuilder</code> class be a friend of
<code>Foo</code> so that it can construct the inner state
of <code>Foo</code> correctly, without exposing this
state to the world. In some cases it may be useful to
make a unittest class a friend of the class it tests.</p>

<p>Friends extend, but do not break, the encapsulation
boundary of a class. In some cases this is better than
making a member public when you want to give only one
other class access to it. However, most classes should
interact with other classes solely through their public
members.</p>

<h3 id="Exceptions">Exceptions</h3>

<p>We do not use C++ exceptions.</p>

<p class="pros"></p>
<ul>
  <li>Exceptions allow higher levels of an application to
  decide how to handle "can't happen" failures in deeply
  nested functions, without the obscuring and error-prone
  bookkeeping of error codes.</li>



  <div>
  <li>Exceptions are used by most other
  modern languages. Using them in C++ would make it more
  consistent with Python, Java, and the C++ that others
  are familiar with.</li>
  </div>

  <li>Some third-party C++ libraries use exceptions, and
  turning them off internally makes it harder to
  integrate with those libraries.</li>

  <li>Exceptions are the only way for a constructor to
  fail. We can simulate this with a factory function or
  an <code>Init()</code> method, but these require heap
  allocation or a new "invalid" state, respectively.</li>

  <li>Exceptions are really handy in testing
  frameworks.</li>
</ul>

<p class="cons"></p>
<ul>
  <li>When you add a <code>throw</code> statement to an
  existing function, you must examine all of its
  transitive callers. Either they must make at least the
  basic exception safety guarantee, or they must never
  catch the exception and be happy with the program
  terminating as a result. For instance, if
  <code>f()</code> calls <code>g()</code> calls
  <code>h()</code>, and <code>h</code> throws an
  exception that <code>f</code> catches, <code>g</code>
  has to be careful or it may not clean up properly.</li>

  <li>More generally, exceptions make the control flow of
  programs difficult to evaluate by looking at code:
  functions may return in places you don't expect. This
  causes maintainability and debugging difficulties. You
  can minimize this cost via some rules on how and where
  exceptions can be used, but at the cost of more that a
  developer needs to know and understand.</li>

  <li>Exception safety requires both RAII and different
  coding practices. Lots of supporting machinery is
  needed to make writing correct exception-safe code
  easy. Further, to avoid requiring readers to understand
  the entire call graph, exception-safe code must isolate
  logic that writes to persistent state into a "commit"
  phase. This will have both benefits and costs (perhaps
  where you're forced to obfuscate code to isolate the
  commit). Allowing exceptions would force us to always
  pay those costs even when they're not worth it.</li>

  <li>Turning on exceptions adds data to each binary
  produced, increasing compile time (probably slightly)
  and possibly increasing address space pressure.
  </li>

  <li>The availability of exceptions may encourage
  developers to throw them when they are not appropriate
  or recover from them when it's not safe to do so. For
  example, invalid user input should not cause exceptions
  to be thrown. We would need to make the style guide
  even longer to document these restrictions!</li>
</ul>

<p class="decision"></p>
<p>On their face, the benefits of using exceptions
outweigh the costs, especially in new projects. However,
for existing code, the introduction of exceptions has
implications on all dependent code. If exceptions can be
propagated beyond a new project, it also becomes
problematic to integrate the new project into existing
exception-free code. Because most existing C++ code at
Google is not prepared to deal with exceptions, it is
comparatively difficult to adopt new code that generates
exceptions.</p>

<p>Given that Google's existing code is not
exception-tolerant, the costs of using exceptions are
somewhat greater than the costs in a new project. The
conversion process would be slow and error-prone. We
don't believe that the available alternatives to
exceptions, such as error codes and assertions, introduce
a significant burden. </p>

<p>Our advice against using exceptions is not predicated
on philosophical or moral grounds, but practical ones.
 Because we'd like to use our open-source
projects at Google and it's difficult to do so if those
projects use exceptions, we need to advise against
exceptions in Google open-source projects as well.
Things would probably be different if we had to do it all
over again from scratch.</p>

<p>This prohibition also applies to the exception handling related
features added in C++11, such as
<code>std::exception_ptr</code> and
<code>std::nested_exception</code>.</p>

<p>There is an <a href="#Windows_Code">exception</a> to
this rule (no pun intended) for Windows code.</p>

<h3 id="noexcept"><code>noexcept</code></h3>

<p>Specify <code>noexcept</code> when it is useful and correct.</p>

<p class="definition"></p>
<p>The <code>noexcept</code> specifier is used to specify whether
a function will throw exceptions or not. If an exception
escapes from a function marked <code>noexcept</code>, the program
crashes via <code>std::terminate</code>.</p>

<p>The <code>noexcept</code> operator performs a compile-time
check that returns true if an expression is declared to not
throw any exceptions.</p>

<p class="pros"></p>
<ul>
  <li>Specifying move constructors as <code>noexcept</code>
  improves performance in some cases, e.g.
  <code>std::vector&lt;T&gt;::resize()</code> moves rather than
  copies the objects if T's move constructor is
  <code>noexcept</code>.</li>

  <li>Specifying <code>noexcept</code> on a function can
  trigger compiler optimizations in environments where
  exceptions are enabled, e.g. compiler does not have to
  generate extra code for stack-unwinding, if it knows
  that no exceptions can be thrown due to a
  <code>noexcept</code> specifier.</li>
</ul>

<p class="cons"></p>
<ul>
  <li>

  In projects following this guide
  that have exceptions disabled it is hard
  to ensure that <code>noexcept</code>
  specifiers are correct, and hard to define what
  correctness even means.</li>

  <li>It's hard, if not impossible, to undo <code>noexcept</code>
  because it eliminates a guarantee that callers may be relying
  on, in ways that are hard to detect.</li>
</ul>

<p class="decision"></p>
<p>You may use <code>noexcept</code> when it is useful for
performance if it accurately reflects the intended semantics
of your function, i.e. that if an exception is somehow thrown
from within the function body then it represents a fatal error.
You can assume that <code>noexcept</code> on move constructors
has a meaningful performance benefit. If you think
there is significant performance benefit from specifying
<code>noexcept</code> on some other function, please discuss it
with
your project leads.</p>

<p>Prefer unconditional <code>noexcept</code> if exceptions are
completely disabled (i.e. most Google C++ environments).
Otherwise, use conditional <code>noexcept</code> specifiers
with simple conditions, in ways that evaluate false only in
the few cases where the function could potentially throw.
The tests might include type traits check on whether the
involved operation might throw (e.g.
<code>std::is_nothrow_move_constructible</code> for
move-constructing objects), or on whether allocation can throw
(e.g. <code>absl::default_allocator_is_nothrow</code> for
standard default allocation). Note in many cases the only
possible cause for an exception is allocation failure (we
believe move constructors should not throw except due to
allocation failure), and there are many applications where it&#8217;s
appropriate to treat memory exhaustion as a fatal error rather
than an exceptional condition that your program should attempt
to recover from.  Even for other
potential failures you should prioritize interface simplicity
over supporting all possible exception throwing scenarios:
instead of writing a complicated <code>noexcept</code> clause
that depends on whether a hash function can throw, for example,
simply document that your component doesn&#8217;t support hash
functions throwing and make it unconditionally
<code>noexcept</code>.</p>

<h3 id="Run-Time_Type_Information__RTTI_">Run-Time Type
Information (RTTI)</h3>

<p>Avoid using Run Time Type Information (RTTI).</p>

<p class="definition"></p>
<p> RTTI allows a
programmer to query the C++ class of an object at run
time. This is done by use of <code>typeid</code> or
<code>dynamic_cast</code>.</p>

<p class="pros"></p>
<p>The standard alternatives to RTTI (described below)
require modification or redesign of the class hierarchy
in question. Sometimes such modifications are infeasible
or undesirable, particularly in widely-used or mature
code.</p>

<p>RTTI can be useful in some unit tests. For example, it
is useful in tests of factory classes where the test has
to verify that a newly created object has the expected
dynamic type. It is also useful in managing the
relationship between objects and their mocks.</p>

<p>RTTI is useful when considering multiple abstract
objects. Consider</p>

<pre>bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast&lt;Derived*&gt;(other);
  if (that == nullptr)
    return false;
  ...
}
</pre>

<p class="cons"></p>
<p>Querying the type of an object at run-time frequently
means a design problem. Needing to know the type of an
object at runtime is often an indication that the design
of your class hierarchy is flawed.</p>

<p>Undisciplined use of RTTI makes code hard to maintain.
It can lead to type-based decision trees or switch
statements scattered throughout the code, all of which
must be examined when making further changes.</p>

<p class="decision"></p>
<p>RTTI has legitimate uses but is prone to abuse, so you
must be careful when using it. You may use it freely in
unittests, but avoid it when possible in other code. In
particular, think twice before using RTTI in new code. If
you find yourself needing to write code that behaves
differently based on the class of an object, consider one
of the following alternatives to querying the type:</p>

<ul>
  <li>Virtual methods are the preferred way of executing
  different code paths depending on a specific subclass
  type. This puts the work within the object itself.</li>

  <li>If the work belongs outside the object and instead
  in some processing code, consider a double-dispatch
  solution, such as the Visitor design pattern. This
  allows a facility outside the object itself to
  determine the type of class using the built-in type
  system.</li>
</ul>

<p>When the logic of a program guarantees that a given
instance of a base class is in fact an instance of a
particular derived class, then a
<code>dynamic_cast</code> may be used freely on the
object.  Usually one
can use a <code>static_cast</code> as an alternative in
such situations.</p>

<p>Decision trees based on type are a strong indication
that your code is on the wrong track.</p>

<pre class="badcode">if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...
</pre>

<p>Code such as this usually breaks when additional
subclasses are added to the class hierarchy. Moreover,
when properties of a subclass change, it is difficult to
find and modify all the affected code segments.</p>

<p>Do not hand-implement an RTTI-like workaround. The
arguments against RTTI apply just as much to workarounds
like class hierarchies with type tags. Moreover,
workarounds disguise your true intent.</p>

<h3 id="Casting">Casting</h3>

<p>Use C++-style casts
like <code>static_cast&lt;float&gt;(double_value)</code>, or brace
initialization for conversion of arithmetic types like
<code>int64 y = int64{1} &lt;&lt; 42</code>. Do not use
cast formats like
<code>int y = (int)x</code> or <code>int y = int(x)</code> (but the latter
is okay when invoking a constructor of a class type).</p>

<p class="definition"></p>
<p> C++ introduced a
different cast system from C that distinguishes the types
of cast operations.</p>

<p class="pros"></p>
<p>The problem with C casts is the ambiguity of the operation;
sometimes you are doing a <em>conversion</em>
(e.g., <code>(int)3.5</code>) and sometimes you are doing
a <em>cast</em> (e.g., <code>(int)"hello"</code>). Brace
initialization and C++ casts can often help avoid this
ambiguity. Additionally, C++ casts are more visible when searching for
them.</p>

<p class="cons"></p>
<p>The C++-style cast syntax is verbose and cumbersome.</p>

<p class="decision"></p>
<p>Do not use C-style casts. Instead, use these C++-style casts when
explicit type conversion is necessary. </p>

<ul>
  <li>Use brace initialization to convert arithmetic types
  (e.g. <code>int64{x}</code>).  This is the safest approach because code
  will not compile if conversion can result in information loss.  The
  syntax is also concise.</li>



  <li>Use <code>static_cast</code> as the equivalent of a C-style cast
  that does value conversion, when you need to
  explicitly up-cast a pointer from a class to its superclass, or when
  you need to explicitly cast a pointer from a superclass to a
  subclass.  In this last case, you must be sure your object is
  actually an instance of the subclass.</li>



  <li>Use <code>const_cast</code> to remove the
  <code>const</code> qualifier (see <a href="#Use_of_const">const</a>).</li>

  <li>Use <code>reinterpret_cast</code> to do unsafe conversions of
  pointer types to and from integer and other pointer
  types. Use this
  only if you know what you are doing and you understand the aliasing
  issues. Also, consider the alternative
  <code>absl::bit_cast</code>.</li>

  <li>Use <code>absl::bit_cast</code> to interpret the raw bits of a
  value using a different type of the same size (a type pun), such as
  interpreting the bits of a <code>double</code> as
  <code>int64</code>.</li>
</ul>

<p>See the <a href="#Run-Time_Type_Information__RTTI_">
RTTI section</a> for guidance on the use of
<code>dynamic_cast</code>.</p>

<h3 id="Streams">Streams</h3>

<p>Use streams where appropriate, and stick to "simple"
usages. Overload <code>&lt;&lt;</code> for streaming only for types
representing values, and write only the user-visible value, not any
implementation details.</p>

<p class="definition"></p>
<p>Streams are the standard I/O abstraction in C++, as
exemplified by the standard header <code>&lt;iostream&gt;</code>.
They are widely used in Google code, mostly for debug logging
and test diagnostics.</p>

<p class="pros"></p>
<p>The <code>&lt;&lt;</code> and <code>&gt;&gt;</code>
stream operators provide an API for formatted I/O that
is easily learned, portable, reusable, and extensible.
<code>printf</code>, by contrast, doesn't even support
<code>std::string</code>, to say nothing of user-defined types,
and is very difficult to use portably.
<code>printf</code> also obliges you to choose among the
numerous slightly different versions of that function,
and navigate the dozens of conversion specifiers.</p>

<p>Streams provide first-class support for console I/O
via <code>std::cin</code>, <code>std::cout</code>,
<code>std::cerr</code>, and <code>std::clog</code>.
The C APIs do as well, but are hampered by the need to
manually buffer the input. </p>

<p class="cons"></p>
<ul>
<li>Stream formatting can be configured by mutating the
state of the stream. Such mutations are persistent, so
the behavior of your code can be affected by the entire
previous history of the stream, unless you go out of your
way to restore it to a known state every time other code
might have touched it. User code can not only modify the
built-in state, it can add new state variables and behaviors
through a registration system.</li>

<li>It is difficult to precisely control stream output, due
to the above issues, the way code and data are mixed in
streaming code, and the use of operator overloading (which
may select a different overload than you expect).</li>

<li>The practice of building up output through chains
of <code>&lt;&lt;</code> operators interferes with
internationalization, because it bakes word order into the
code, and streams' support for localization is <a href="http://www.boost.org/doc/libs/1_48_0/libs/locale/doc/html/rationale.html#rationale_why">
flawed</a>.</li>





<li>The streams API is subtle and complex, so programmers must
develop experience with it in order to use it effectively.</li>

<li>Resolving the many overloads of <code>&lt;&lt;</code> is
extremely costly for the compiler. When used pervasively in a
large code base, it can consume as much as 20% of the parsing
and semantic analysis time.</li>
</ul>

<p class="decision"></p>
<p>Use streams only when they are the best tool for the job.
This is typically the case when the I/O is ad-hoc, local,
human-readable, and targeted at other developers rather than
end-users. Be consistent with the code around you, and with the
codebase as a whole; if there's an established tool for
your problem, use that tool instead.
In particular,

logging libraries are usually a better
choice than <code>std::cerr</code> or <code>std::clog</code>
for diagnostic output, and the libraries in

<code>absl/strings</code>
or the equivalent are usually a
better choice than <code>std::stringstream</code>.</p>

<p>Avoid using streams for I/O that faces external users or
handles untrusted data. Instead, find and use the appropriate
templating libraries to handle issues like internationalization,
localization, and security hardening.</p>

<p>If you do use streams, avoid the stateful parts of the
streams API (other than error state), such as <code>imbue()</code>,
<code>xalloc()</code>, and <code>register_callback()</code>.
Use explicit formatting functions (see e.g.

<code>absl/strings</code>)
rather than
stream manipulators or formatting flags to control formatting
details such as number base, precision, or padding.</p>

<p>Overload <code>&lt;&lt;</code> as a streaming operator
for your type only if your type represents a value, and
<code>&lt;&lt;</code> writes out a human-readable string
representation of that value. Avoid exposing implementation
details in the output of <code>&lt;&lt;</code>; if you need to print
object internals for debugging, use named functions instead
(a method named <code>DebugString()</code> is the most common
convention).</p>

<h3 id="Preincrement_and_Predecrement">Preincrement and Predecrement</h3>

<p>Use prefix form (<code>++i</code>) of the increment and
decrement operators with iterators and other template
objects.</p>

<p class="definition"></p>
<p> When a variable
is incremented (<code>++i</code> or <code>i++</code>) or
decremented (<code>--i</code> or <code>i--</code>) and
the value of the expression is not used, one must decide
whether to preincrement (decrement) or postincrement
(decrement).</p>

<p class="pros"></p>
<p>When the return value is ignored, the "pre" form
(<code>++i</code>) is never less efficient than the
"post" form (<code>i++</code>), and is often more
efficient. This is because post-increment (or decrement)
requires a copy of <code>i</code> to be made, which is
the value of the expression. If <code>i</code> is an
iterator or other non-scalar type, copying <code>i</code>
could be expensive. Since the two types of increment
behave the same when the value is ignored, why not just
always pre-increment?</p>

<p class="cons"></p>
<p>The tradition developed, in C, of using post-increment
when the expression value is not used, especially in
<code>for</code> loops. Some find post-increment easier
to read, since the "subject" (<code>i</code>) precedes
the "verb" (<code>++</code>), just like in English.</p>

<p class="decision"></p>
<p> For simple scalar
(non-object) values there is no reason to prefer one form
and we allow either. For iterators and other template
types, use pre-increment.</p>

<h3 id="Use_of_const">Use of const</h3>

<p>In APIs, use <code>const</code> whenever it makes sense.
<code>constexpr</code> is a better choice for some uses of
const.</p>

<p class="definition"></p>
<p> Declared variables and parameters can be preceded
by the keyword <code>const</code> to indicate the variables
are not changed (e.g., <code>const int foo</code>). Class
functions can have the <code>const</code> qualifier to
indicate the function does not change the state of the
class member variables (e.g., <code>class Foo { int
Bar(char c) const; };</code>).</p>

<p class="pros"></p>
<p>Easier for people to understand how variables are being
used. Allows the compiler to do better type checking,
and, conceivably, generate better code. Helps people
convince themselves of program correctness because they
know the functions they call are limited in how they can
modify your variables. Helps people know what functions
are safe to use without locks in multi-threaded
programs.</p>

<p class="cons"></p>
<p><code>const</code> is viral: if you pass a
<code>const</code> variable to a function, that function
must have <code>const</code> in its prototype (or the
variable will need a <code>const_cast</code>). This can
be a particular problem when calling library
functions.</p>

<p class="decision"></p>
<p>We strongly recommend using <code>const</code>
in APIs (i.e. on function parameters, methods, and
non-local variables) wherever it is meaningful and accurate. This
provides consistent, mostly compiler-verified documentation
of what objects an operation can mutate. Having
a consistent and reliable way to distinguish reads from writes
is critical to writing thread-safe code, and is useful in
many other contexts as well. In particular:</p>

<ul>
  <li>If a function guarantees that it will not modify an argument
  passed by reference or by pointer, the corresponding function parameter
  should be a reference-to-const (<code>const T&amp;</code>) or
  pointer-to-const (<code>const T*</code>), respectively.</li>

  <li>For a function parameter passed by value, <code>const</code> has
  no effect on the caller, thus is not recommended in function
  declarations. See


  <a href="https://abseil.io/tips/109">TotW #109</a>.


  </li><li>Declare methods to be <code>const</code> unless they
  alter the logical state of the object (or enable the user to modify
  that state, e.g. by returning a non-const reference, but that's
  rare), or they can't safely be invoked concurrently.</li>
</ul>

<p>Using <code>const</code> on local variables is neither encouraged
nor discouraged.</p>

<p>All of a class's <code>const</code> operations should be safe
to invoke concurrently with each other. If that's not feasible, the class must
be clearly documented as "thread-unsafe".</p>


<h4>Where to put the const</h4>

<p>Some people favor the form <code>int const *foo</code>
to <code>const int* foo</code>. They argue that this is
more readable because it's more consistent: it keeps the
rule that <code>const</code> always follows the object
it's describing. However, this consistency argument
doesn't apply in codebases with few deeply-nested pointer
expressions since most <code>const</code> expressions
have only one <code>const</code>, and it applies to the
underlying value. In such cases, there's no consistency
to maintain. Putting the <code>const</code> first is
arguably more readable, since it follows English in
putting the "adjective" (<code>const</code>) before the
"noun" (<code>int</code>).</p>

<p>That said, while we encourage putting
<code>const</code> first, we do not require it. But be
consistent with the code around you!</p>

<h3 id="Use_of_constexpr">Use of constexpr</h3>

<p>Use <code>constexpr</code> to define true
constants or to ensure constant initialization.</p>

<p class="definition"></p>
<p> Some variables can be declared <code>constexpr</code>
to indicate the variables are true constants, i.e. fixed at
compilation/link time. Some functions and constructors
can be declared <code>constexpr</code> which enables them
to be used in defining a <code>constexpr</code>
variable.</p>

<p class="pros"></p>
<p>Use of <code>constexpr</code> enables definition of
constants with floating-point expressions rather than
just literals; definition of constants of user-defined
types; and definition of constants with function
calls.</p>

<p class="cons"></p>
<p>Prematurely marking something as constexpr may cause
migration problems if later on it has to be downgraded.
Current restrictions on what is allowed in constexpr
functions and constructors may invite obscure workarounds
in these definitions.</p>

<p class="decision"></p>
<p><code>constexpr</code> definitions enable a more
robust specification of the constant parts of an
interface. Use <code>constexpr</code> to specify true
constants and the functions that support their
definitions. Avoid complexifying function definitions to
enable their use with <code>constexpr</code>. Do not use
<code>constexpr</code> to force inlining.</p>

<h3 id="Integer_Types">Integer Types</h3>

<p>Of the built-in C++ integer types, the only one used
 is
<code>int</code>. If a program needs a variable of a
different size, use
a precise-width integer type from
<code>&lt;stdint.h&gt;</code>, such as
<code>int16_t</code>. If your variable represents a
value that could ever be greater than or equal to 2^31
(2GiB), use a 64-bit type such as
<code>int64_t</code>.
Keep in mind that even if your value won't ever be too large
for an <code>int</code>, it may be used in intermediate
calculations which may require a larger type. When in doubt,
choose a larger type.</p>

<p class="definition"></p>
<p> C++ does not specify the sizes of integer types
like <code>int</code>. Typically people assume
that <code>short</code> is 16 bits,
<code>int</code> is 32 bits, <code>long</code> is 32 bits
and <code>long long</code> is 64 bits.</p>

<p class="pros"></p>
<p>Uniformity of declaration.</p>

<p class="cons"></p>
<p>The sizes of integral types in C++ can vary based on
compiler and architecture.</p>

<p class="decision"></p>

<p>
<code>&lt;cstdint&gt;</code> defines types
like <code>int16_t</code>, <code>uint32_t</code>,
<code>int64_t</code>, etc. You should always use
those in preference to <code>short</code>, <code>unsigned
long long</code> and the like, when you need a guarantee
on the size of an integer. Of the C integer types, only
<code>int</code> should be used. When appropriate, you
are welcome to use standard types like
<code>size_t</code> and <code>ptrdiff_t</code>.</p>

<p>We use <code>int</code> very often, for integers we
know are not going to be too big, e.g., loop counters.
Use plain old <code>int</code> for such things. You
should assume that an <code>int</code> is

at least 32 bits, but don't
assume that it has more than 32 bits. If you need a 64-bit
integer type, use
<code>int64_t</code>
or
<code>uint64_t</code>.</p>

<p>For integers we know can be "big",
 use
<code>int64_t</code>.
</p>

<p>You should not use the unsigned integer types such as

<code>uint32_t</code>, unless there is a valid
reason such as representing a bit pattern rather than a
number, or you need defined overflow modulo 2^N. In
particular, do not use unsigned types to say a number
will never be negative. Instead, use

assertions for this.</p>



<p>If your code is a container that returns a size, be
sure to use a type that will accommodate any possible
usage of your container. When in doubt, use a larger type
rather than a smaller type.</p>

<p>Use care when converting integer types. Integer conversions and
promotions can cause undefined behavior, leading to security bugs and
other problems.</p>

<h4>On Unsigned Integers</h4>

<p>Unsigned integers are good for representing bitfields and modular
arithmetic. Because of historical accident, the C++ standard also uses
unsigned integers to represent the size of containers - many members
of the standards body believe this to be a mistake, but it is
effectively impossible to fix at this point. The fact that unsigned
arithmetic doesn't model the behavior of a simple integer, but is
instead defined by the standard to model modular arithmetic (wrapping
around on overflow/underflow), means that a significant class of bugs
cannot be diagnosed by the compiler. In other cases, the defined
behavior impedes optimization.</p>

<p>That said, mixing signedness of integer types is responsible for an
equally large class of problems. The best advice we can provide: try
to use iterators and containers rather than pointers and sizes, try
not to mix signedness, and try to avoid unsigned types (except for
representing bitfields or modular arithmetic). Do not use an unsigned
type merely to assert that a variable is non-negative.</p>

<h3 id="64-bit_Portability">64-bit Portability</h3>

<p>Code should be 64-bit and 32-bit friendly. Bear in mind
problems of printing, comparisons, and structure alignment.</p>

<ul>
  <li>
  <p>Correct portable <code>printf()</code> conversion specifiers for
  some integral typedefs rely on macro expansions that we find unpleasant to
  use and impractical to require (the <code>PRI</code> macros from
  <code>&lt;cinttypes&gt;</code>). Unless there is no reasonable alternative
  for your particular case, try to avoid or even upgrade APIs that rely on the
  <code>printf</code> family. Instead use a library supporting typesafe numeric
  formatting, such as


    <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/str_cat.h"><code>StrCat</code></a>

    or


    <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/strings/substitute.h"><code>Substitute</code></a>

    for fast simple conversions,

    or <a href="#Streams"><code>std::ostream</code></a>.</p>

  <p>Unfortunately, the <code>PRI</code> macros are the only portable way to
  specify a conversion for the standard bitwidth typedefs (e.g.
  <code>int64_t</code>, <code>uint64_t</code>, <code>int32_t</code>,
  <code>uint32_t</code>, etc).

  Where possible, avoid passing arguments of types specified by bitwidth
  typedefs to <code>printf</code>-based APIs. Note that it is acceptable
  to use typedefs for which printf has dedicated length modifiers, such as
  <code>size_t</code> (<code>z</code>),
  <code>ptrdiff_t</code> (<code>t</code>), and
  <code>maxint_t</code> (<code>j</code>).</p>
  </li>

  <li>Remember that <code>sizeof(void *)</code> !=
  <code>sizeof(int)</code>. Use <code>intptr_t</code> if
  you want a pointer-sized integer.</li>

  <li>You may need to be careful with structure
  alignments, particularly for structures being stored on
  disk. Any class/structure with a
  <code>int64_t</code>/<code>uint64_t</code>
  member will by default end up being 8-byte aligned on a
  64-bit system. If you have such structures being shared
  on disk between 32-bit and 64-bit code, you will need
  to ensure that they are packed the same on both
  architectures.
  Most compilers offer a way to
  alter structure alignment. For gcc, you can use
  <code>__attribute__((packed))</code>. MSVC offers
  <code>#pragma pack()</code> and
  <code>__declspec(align())</code>.</li>

  <li>
  <p>Use <a href="#Casting">braced-initialization</a> as needed to create
  64-bit constants. For example:</p>


<div>
<pre>int64_t my_value{0x123456789};
uint64_t my_mask{3ULL &lt;&lt; 48};
</pre>
</div>
  </li>
</ul>

<h3 id="Preprocessor_Macros">Preprocessor Macros</h3>

<p>Avoid defining macros, especially in headers; prefer
inline functions, enums, and <code>const</code> variables.
Name macros with a project-specific prefix. Do not use
macros to define pieces of a C++ API.</p>

<p>Macros mean that the code you see is not the same as
the code the compiler sees. This can introduce unexpected
behavior, especially since macros have global scope.</p>

<p>The problems introduced by macros are especially severe
when they are used to define pieces of a C++ API,
and still more so for public APIs. Every error message from
the compiler when developers incorrectly use that interface
now must explain how the macros formed the interface.
Refactoring and analysis tools have a dramatically harder
time updating the interface. As a consequence, we
specifically disallow using macros in this way.
For example, avoid patterns like:</p>

<pre class="badcode">class WOMBAT_TYPE(Foo) {
  // ...

 public:
  EXPAND_PUBLIC_WOMBAT_API(Foo)

  EXPAND_WOMBAT_COMPARISONS(Foo, ==, &lt;)
};
</pre>

<p>Luckily, macros are not nearly as necessary in C++ as
they are in C. Instead of using a macro to inline
performance-critical code, use an inline function.
Instead of using a macro to store a constant, use a
<code>const</code> variable. Instead of using a macro to
"abbreviate" a long variable name, use a reference.
Instead of using a macro to conditionally compile code
... well, don't do that at all (except, of course, for
the <code>#define</code> guards to prevent double
inclusion of header files). It makes testing much more
difficult.</p>

<p>Macros can do things these other techniques cannot,
and you do see them in the codebase, especially in the
lower-level libraries. And some of their special features
(like stringifying, concatenation, and so forth) are not
available through the language proper. But before using a
macro, consider carefully whether there's a non-macro way
to achieve the same result. If you need to use a macro to
define an interface, contact
your project leads to request
a waiver of this rule.</p>

<p>The following usage pattern will avoid many problems
with macros; if you use macros, follow it whenever
possible:</p>

<ul>
  <li>Don't define macros in a <code>.h</code> file.</li>

  <li><code>#define</code> macros right before you use
  them, and <code>#undef</code> them right after.</li>

  <li>Do not just <code>#undef</code> an existing macro
  before replacing it with your own; instead, pick a name
  that's likely to be unique.</li>

  <li>Try not to use macros that expand to unbalanced C++
  constructs, or at least document that behavior
  well.</li>

  <li>Prefer not using <code>##</code> to generate
  function/class/variable names.</li>
</ul>

<p>Exporting macros from headers (i.e. defining them in a header
without <code>#undef</code>ing them before the end of the header)
is extremely strongly discouraged. If you do export a macro from a
header, it must have a globally unique name. To achieve this, it
must be named with a prefix consisting of your project's namespace
name (but upper case). </p>

<h3 id="0_and_nullptr/NULL">0 and nullptr/NULL</h3>

<p>Use <code>nullptr</code> for pointers, and <code>'\0'</code> for chars (and
not the <code>0</code> literal).</p>

<p>For pointers (address values), use <code>nullptr</code>, as this
provides type-safety.</p>

<p>For C++03 projects, prefer <code>NULL</code> to <code>0</code>. While the
values are equivalent, <code>NULL</code> looks more like a pointer to the
reader, and some C++ compilers provide special definitions of <code>NULL</code>
which enable them to give useful warnings. Never use <code>NULL</code> for
numeric (integer or floating-point) values.</p>

<p>Use <code>'\0'</code> for the null character. Using the correct type makes
the code more readable.</p>

<h3 id="sizeof">sizeof</h3>

<p>Prefer <code>sizeof(<var>varname</var>)</code> to
<code>sizeof(<var>type</var>)</code>.</p>

<p>Use <code>sizeof(<var>varname</var>)</code> when you
take the size of a particular variable.
<code>sizeof(<var>varname</var>)</code> will update
appropriately if someone changes the variable type either
now or later. You may use
<code>sizeof(<var>type</var>)</code> for code unrelated
to any particular variable, such as code that manages an
external or internal data format where a variable of an
appropriate C++ type is not convenient.</p>

<pre>struct data;
memset(&amp;data, 0, sizeof(data));
</pre>

<pre class="badcode">memset(&amp;data, 0, sizeof(Struct));
</pre>

<pre>if (raw_size &lt; sizeof(int)) {
  LOG(ERROR) &lt;&lt; "compressed record not big enough for count: " &lt;&lt; raw_size;
  return false;
}
</pre>

<h3 id="Type_deduction">Type deduction</h3>

<p>Use type deduction only if it makes the code clearer to readers who aren't
  familiar with the project, or if it makes the code safer. Do not use it
  merely to avoid the inconvenience of writing an explicit type.</p>

<p class="definition"></p>

<p>There are several contexts in which C++ allows (or even requires) types to
be deduced by the compiler, rather than spelled out explicitly in the code:</p>
<dl>
  <dt><a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">Function template argument deduction</a></dt>
  <dd>A function template can be invoked without explicit template arguments.
    The compiler deduces those arguments from the types of the function
    arguments:
    <pre class="neutralcode">template &lt;typename T&gt;
void f(T t);

f(0);  // Invokes f&lt;int&gt;(0)</pre>
  </dd>
  <dt><a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code> variable declarations</a></dt>
  <dd>A variable declaration can use the <code>auto</code> keyword in place
    of the type. The compiler deduces the type from the variable's
    initializer, following the same rules as function template argument
    deduction with the same initializer (so long as you don't use curly braces
    instead of parentheses).
    <pre class="neutralcode">auto a = 42;  // a is an int
auto&amp; b = a;  // b is an int&amp;
auto c = b;   // c is an int
auto d{42};   // d is an int, not a std::initializer_list&lt;int&gt;
</pre>
    <code>auto</code> can be qualified with <code>const</code>, and can be
    used as part of a pointer or reference type, but it can't be used as a
    template argument. A rare variant of this syntax uses
    <code>decltype(auto)</code> instead of <code>auto</code>, in which case
    the deduced type is the result of applying
    <a href="https://en.cppreference.com/w/cpp/language/decltype"><code>decltype</code></a>
    to the initializer.
  </dd>
  <dt><a href="https://en.cppreference.com/w/cpp/language/function#Return_type_deduction">Function return type deduction</a></dt>
  <dd><code>auto</code> (and <code>decltype(auto)</code>) can also be used in
    place of a function return type. The compiler deduces the return type from
    the <code>return</code> statements in the function body, following the same
    rules as for variable declarations:
    <pre class="neutralcode">auto f() { return 0; }  // The return type of f is int</pre>
    <a href="#Lambda_expressions">Lambda expression</a> return types can be
    deduced in the same way, but this is triggered by omitting the return type,
    rather than by an explicit <code>auto</code>. Confusingly,
    <a href="trailing_return">trailing return type</a> syntax for functions
    also uses <code>auto</code> in the return-type position, but that doesn't
    rely on type deduction; it's just an alternate syntax for an explicit
    return type.
  </dd>
  <dt><a href="https://isocpp.org/wiki/faq/cpp14-language#generic-lambdas">Generic lambdas</a></dt>
  <dd>A lambda expression can use the <code>auto</code> keyword in place of
    one or more of its parameter types. This causes the lambda's call operator
    to be a function template instead of an ordinary function, with a separate
    template parameter for each <code>auto</code> function parameter:
    <pre class="neutralcode">// Sort `vec` in increasing order
std::sort(vec.begin(), vec.end(), [](auto lhs, auto rhs) { return lhs &gt; rhs; });</pre>
  </dd>
  <dt><a href="https://isocpp.org/wiki/faq/cpp14-language#lambda-captures">Lambda init captures</a></dt>
  <dd>Lambda captures can have explicit initializers, which can be used to
    declare wholly new variables rather than only capturing existing ones:
    <pre class="neutralcode">[x = 42, y = "foo"] { ... }  // x is an int, and y is a const char*</pre>
    This syntax doesn't allow the type to be specified; instead, it's deduced
    using the rules for <code>auto</code> variables.
  </dd>
  <dt><a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Class template argument deduction</a></dt>
  <dd>See <a href="#CTAD">below</a>.</dd>
  <dt><a href="https://en.cppreference.com/w/cpp/language/structured_binding">Structured bindings</a></dt>
  <dd>When declaring a tuple, struct, or array using <code>auto</code>, you can
    specify names for the individual elements instead of a name for the whole
    object; these names are called "structured bindings", and the whole
    declaration is called a "structured binding declaration". This syntax
    provides no way of specifying the type of either the enclosing object
    or the individual names:
    <pre class="neutralcode">auto [iter, success] = my_map.insert({key, value});
if (!success) {
  iter-&gt;second = value;
}</pre>
    The <code>auto</code> can also be qualified with <code>const</code>,
    <code>&amp;</code>, and <code>&amp;&amp;</code>, but note that these qualifiers
    technically apply to the anonymous tuple/struct/array, rather than the
    individual bindings. The rules that determine the types of the bindings
    are quite complex; the results tend to be unsurprising, except that
    the binding types typically won't be references even if the declaration
    declares a reference (but they will usually behave like references anyway).
  </dd></dl>

<p>(These summaries omit many details and caveats; see the links for further
  information.)</p>

<p class="pros"></p>

<ul>
  <li>C++ type names can be long and cumbersome, especially when they
    involve templates or namespaces.</li>
  <li>When a C++ type name is repeated within a single declaration or a
    small code region, the repetition may not be aiding readability.</li>
  <li>It is sometimes safer to let the type be deduced, since that avoids
    the possibility of unintended copies or type conversions.</li>
</ul>

<p class="cons"></p>
<p>C++ code is usually clearer when types are explicit,
  especially when type deduction would depend on information from
  distant parts of the code. In expressions like:</p>

<pre class="badcode">auto foo = x.add_foo();
auto i = y.Find(key);
</pre>

<p>it may not be obvious what the resulting types are if the type
  of <code>y</code> isn't very well known, or if <code>y</code> was
  declared many lines earlier.</p>

<p>Programmers have to understand when type deduction will or won't
  produce a reference type, or they'll get copies when they didn't
  mean to.</p>

<p>If a deduced type is used as part of an interface, then a
  programmer might change its type while only intending to
  change its value, leading to a more radical API change
  than intended.</p>

<p class="decision"></p>

<p>The fundamental rule is: use type deduction only to make the code
  clearer or safer, and do not use it merely to avoid the
  inconvenience of writing an explicit type. When judging whether the
  code is clearer, keep in mind that your readers are not necessarily
  on your team, or familiar with your project, so types that you and
  your reviewer experience as as unnecessary clutter will very often
  provide useful information to others. For example, you can assume that
  the return type of <code>make_unique&lt;Foo&gt;()</code> is obvious,
  but the return type of <code>MyWidgetFactory()</code> probably isn't.</p>

  <p>These principles applies to all forms of type deduction, but the
  details vary, as described in the following sections.</p>

<h4>Function template argument deduction</h4>

<p>Function template argument deduction is almost always OK. Type deduction
  is the expected default way of interacting with function templates,
  because it allows function templates to act like infinite sets of ordinary
  function overloads. Consequently, function templates are almost always
  designed so that template argument deduction is clear and safe, or
  doesn't compile.</p>

<h4>Local variable type deduction</h4>

<p>For local variables, you can use type deduction to make the code clearer
  by eliminating type information that is obvious or irrelevant, so that
  the reader can focus on the meaningful parts of the code:
  </p><pre class="neutralcode">std::unique_ptr&lt;WidgetWithBellsAndWhistles&gt; widget_ptr =
    absl::make_unique&lt;WidgetWithBellsAndWhistles&gt;(arg1, arg2);
absl::flat_hash_map&lt;std::string,
                    std::unique_ptr&lt;WidgetWithBellsAndWhistles&gt;&gt;::const_iterator
    it = my_map_.find(key);
std::array&lt;int, 0&gt; numbers = {4, 8, 15, 16, 23, 42};</pre>

  <pre class="goodcode">auto widget_ptr = absl::make_unique&lt;WidgetWithBellsAndWhistles&gt;(arg1, arg2);
auto it = my_map_.find(key);
std::array numbers = {4, 8, 15, 16, 23, 42};</pre>

<p>Types sometimes contain a mixture of useful information and boilerplate,
  such as <code>it</code> in the example above: it's obvious that the
  type is an iterator, and in many contexts the container type and even the
  key type aren't relevant, but the type of the values is probably useful.
  In such situations, it's often possible to define local variables with
  explicit types that convey the relevant information:
  </p><pre class="goodcode">auto it = my_map_.find(key);
if (it != my_map_.end()) {
  WidgetWithBellsAndWhistles&amp; widget = *it-&gt;second;
  // Do stuff with `widget`
}</pre>
    <p>
        If the type is a template instance, and the parameters are
        boilerplate but the template itself is informative, you can use
        class template argument deduction to suppress the boilerplate. However,
        cases where this actually provides a meaningful benefit are quite rare.
        Note that class template argument deduction is also subject to a
        <a href="#CTAD">separate style rule</a>.
    </p>

<p>Do not use <code>decltype(auto)</code> if a simpler option will work,
  because it's a fairly obscure feature, so it has a high cost in code
  clarity.</p>

<h4>Return type deduction</h4>

<p>Use return type deduction (for both functions and lambdas) only if the
  function body has a very small number of <code>return</code> statements,
  and very little other code, because otherwise the reader may not be able
  to tell at a glance what the return type is. Furthermore, use it only
  if the function or lambda has a very narrow scope, because functions with
  deduced return types don't define abstraction boundaries: the implementation
  <em>is</em> the interface. In particular, public functions in header files
  should almost never have deduced return types.</p>

<h4>Parameter type deduction</h4>

<p><code>auto</code> parameter types for lambdas should be used with caution,
  because the actual type is determined by the code that calls the lambda,
  rather than by the definition of the lambda. Consequently, an explicit
  type will almost always be clearer unless the lambda is explicitly called
  very close to where it's defined (so that the reader can easily see both),
  or the lambda is passed to an interface so well-known that it's
  obvious what arguments it will eventually be called with (e.g.
  the <code>std::sort</code> example above).</p>

<h4>Lambda init captures</h4>

<p>Init captures are covered by a <a href="#Lambda_expressions">more specific
    style rule</a>, which largely supersedes the general rules for
  type deduction.</p>

<h4>Structured bindings</h4>

<p>Unlike other forms of type deduction, structured bindings can actually
  give the reader additional information, by giving meaningful names to the
  elements of a larger object. This means that a structured binding declaration
  may provide a net readability improvement over an explicit type, even in cases
  where <code>auto</code> would not. Structured bindings are especially
  beneficial when the object is a pair or tuple (as in the <code>insert</code>
  example above), because they don't have meaningful field names to begin with,
  but note that you generally <a href="#Structs_vs._Tuples">shouldn't use
    pairs or tuples</a> unless a pre-existing API like <code>insert</code>
  forces you to.</p>

<p>If the object being bound is a struct, it may sometimes be helpful to
  provide names that are more specific to your usage, but keep in mind that
  this may also mean the names are less recognizable to your reader than the
  field names. We recommend using a comment to indicate the name of the
  underlying field, if it doesn't match the name of the binding, using the
  same syntax as for function parameter comments:
  </p><pre>auto [/*field_name1=*/ bound_name1, /*field_name2=*/ bound_name2] = ...</pre>
<p>As with function parameter comments, this can enable tools to detect if
  you get the order of the fields wrong.</p>

<h3 id="CTAD">Class template argument deduction</h3>

<p>Use class template argument deduction only with templates that have
  explicitly opted into supporting it.</p>

<p class="definition"></p>
<p><a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">Class
    template argument deduction</a> (often abbreviated "CTAD") occurs when
  a variable is declared with a type that names a template, and the template
  argument list is not provided (not even empty angle brackets):
  </p><pre class="neutralcode">std::array a = {1, 2, 3};  // `a` is a std::array&lt;int, 3&gt;</pre>
    <p>
        The compiler deduces the arguments from the initializer using the
        template's "deduction guides", which can be explicit or implicit.
    </p>
<p>Explicit deduction guides look like function declarations with trailing
  return types, except that there's no leading <code>auto</code>, and the
  function name is the name of the template. For example, the above example
  relies on this deduction guide for <code>std::array</code>:
  </p><pre class="neutralcode">namespace std {
template &lt;class T, class... U&gt;
array(T, U...) -&gt; std::array&lt;T, 1 + sizeof...(U)&gt;;
}</pre>
    <p>
        Constructors in a primary template (as opposed to a template specialization)
        also implicitly define deduction guides.
    </p>

<p>When you declare a variable that relies on CTAD, the compiler selects
  a deduction guide using the rules of constructor overload resolution,
  and that guide's return type becomes the type of the variable.</p>

<p class="pros"></p>
<p>CTAD can sometimes allow you to omit boilerplate from your code.</p>

<p class="cons"></p>
<p>The implicit deduction guides that are generated from constructors
  may have undesirable behavior, or be outright incorrect. This is
  particularly problematic for constructors written before CTAD was
  introduced in C++17, because the authors of those constructors had no
  way of knowing about (much less fixing) any problems that their
  constructors would cause for CTAD. Furthermore, adding explicit deduction
  guides to fix those problems might break any existing code that relies on
  the implicit deduction guides.</p>

<p>CTAD also suffers from many of the same drawbacks as <code>auto</code>,
  because they are both mechanisms for deducing all or part of a variable's
  type from its initializer. CTAD does give the reader more information
  than <code>auto</code>, but it also doesn't give the reader an obvious
  cue that information has been omitted.</p>

<p class="decision"></p>
<p>Do not use CTAD with a given template unless the template's maintainers
  have opted into supporting use of CTAD by providing at least one explicit
  deduction guide (all templates in the <code>std</code> namespace are
  also presumed to have opted in). This should be enforced with a compiler
  warning if available.</p>

<p>Uses of CTAD must also follow the general rules on
  <a href="#Type_deduction">Type deduction</a>.</p>

<h3 id="Lambda_expressions">Lambda expressions</h3>

<p>Use lambda expressions where appropriate. Prefer explicit captures
when the lambda will escape the current scope.</p>

<p class="definition"></p>
<p> Lambda expressions are a concise way of creating anonymous
function objects. They're often useful when passing
functions as arguments. For example:</p>

<pre>std::sort(v.begin(), v.end(), [](int x, int y) {
  return Weight(x) &lt; Weight(y);
});
</pre>

<p> They further allow capturing variables from the enclosing scope either
explicitly by name, or implicitly using a default capture. Explicit captures
require each variable to be listed, as
either a value or reference capture:</p>

<pre>int weight = 3;
int sum = 0;
// Captures `weight` by value and `sum` by reference.
std::for_each(v.begin(), v.end(), [weight, &amp;sum](int x) {
  sum += weight * x;
});
</pre>


<p>Default captures implicitly capture any variable referenced in the
lambda body, including <code>this</code> if any members are used:</p>

<pre>const std::vector&lt;int&gt; lookup_table = ...;
std::vector&lt;int&gt; indices = ...;
// Captures `lookup_table` by reference, sorts `indices` by the value
// of the associated element in `lookup_table`.
std::sort(indices.begin(), indices.end(), [&amp;](int a, int b) {
  return lookup_table[a] &lt; lookup_table[b];
});
</pre>

<p>A variable capture can also have an explicit initializer, which can
  be used for capturing move-only variables by value, or for other situations
  not handled by ordinary reference or value captures:
  </p><pre>std::unique_ptr&lt;Foo&gt; foo = ...;
[foo = std::move(foo)] () {
  ...
}</pre>
    <p>
        Such captures (often called "init captures" or "generalized lambda captures")
        need not actually "capture" anything from the enclosing scope, or even have
        a name from the enclosing scope; this syntax is a fully general way to define
        members of a lambda object:
    </p>
  <pre class="neutralcode">[foo = std::vector&lt;int&gt;({1, 2, 3})] () {
  ...
}</pre>
    <p>
        The type of a capture with an initializer is deduced using the same rules
        as <code>auto</code>.
    </p>

<p class="pros"></p>
<ul>
  <li>Lambdas are much more concise than other ways of
   defining function objects to be passed to STL
   algorithms, which can be a readability
   improvement.</li>

  <li>Appropriate use of default captures can remove
    redundancy and highlight important exceptions from
    the default.</li>

   <li>Lambdas, <code>std::function</code>, and
   <code>std::bind</code> can be used in combination as a
   general purpose callback mechanism; they make it easy
   to write functions that take bound functions as
   arguments.</li>
</ul>

<p class="cons"></p>
<ul>
  <li>Variable capture in lambdas can be a source of dangling-pointer
  bugs, particularly if a lambda escapes the current scope.</li>

  <li>Default captures by value can be misleading because they do not prevent
  dangling-pointer bugs. Capturing a pointer by value doesn't cause a deep
  copy, so it often has the same lifetime issues as capture by reference.
  This is especially confusing when capturing 'this' by value, since the use
  of 'this' is often implicit.</li>

  <li>Captures actually declare new variables (whether or not the captures have
    initializers), but they look nothing like any other variable declaration
    syntax in C++. In particular, there's no place for the variable's type,
    or even an <code>auto</code> placeholder (although init captures can
    indicate it indirectly, e.g. with a cast). This can make it difficult to
    even recognize them as declarations.</li>

  <li>Init captures inherently rely on <a href="#Type_deduction">type
      deduction</a>, and suffer from many of the same drawbacks as
    <code>auto</code>, with the additional problem that the syntax doesn't
    even cue the reader that deduction is taking place.</li>

  <li>It's possible for use of lambdas to get out of
  hand; very long nested anonymous functions can make
  code harder to understand.</li>

</ul>

<p class="decision"></p>
<ul>
<li>Use lambda expressions where appropriate, with formatting as
described <a href="#Formatting_Lambda_Expressions">below</a>.</li>
<li>Prefer explicit captures if the lambda may escape the current scope.
For example, instead of:
<pre class="badcode">{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;] { Frobnicate(foo); })
  ...
}
// BAD! The fact that the lambda makes use of a reference to `foo` and
// possibly `this` (if `Frobnicate` is a member function) may not be
// apparent on a cursory inspection. If the lambda is invoked after
// the function returns, that would be bad, because both `foo`
// and the enclosing object could have been destroyed.
</pre>
prefer to write:
<pre>{
  Foo foo;
  ...
  executor-&gt;Schedule([&amp;foo] { Frobnicate(foo); })
  ...
}
// BETTER - The compile will fail if `Frobnicate` is a member
// function, and it's clearer that `foo` is dangerously captured by
// reference.
</pre>
</li>
<li>Use default capture by reference ([&amp;]) only when the
lifetime of the lambda is obviously shorter than any potential
captures.
</li>
<li>Use default capture by value ([=]) only as a means of binding a
few variables for a short lambda, where the set of captured
variables is obvious at a glance. Prefer not to write long or
complex lambdas with default capture by value.
</li>
<li>Use captures only to actually capture variables from the enclosing scope.
  Do not use captures with initializers to introduce new names, or
  to substantially change the meaning of an existing name. Instead,
  declare a new variable in the conventional way and then capture it,
  or avoid the lambda shorthand and define a function object explicitly.</li>
<li>See the section on <a href="#Type_deduction">type deduction</a>
  for guidance on specifying the parameter and return types.</li>

</ul>

<h3 id="Template_metaprogramming">Template metaprogramming</h3>

<p>Avoid complicated template programming.</p>

<p class="definition"></p>
<p>Template metaprogramming refers to a family of techniques that
exploit the fact that the C++ template instantiation mechanism is
Turing complete and can be used to perform arbitrary compile-time
computation in the type domain.</p>

<p class="pros"></p>
<p>Template metaprogramming allows extremely flexible interfaces that
are type safe and high performance. Facilities like

<a href="https://code.google.com/p/googletest/">Google Test</a>,
<code>std::tuple</code>, <code>std::function</code>, and
Boost.Spirit would be impossible without it.</p>

<p class="cons"></p>
<p>The techniques used in template metaprogramming are often obscure
to anyone but language experts. Code that uses templates in
complicated ways is often unreadable, and is hard to debug or
maintain.</p>

<p>Template metaprogramming often leads to extremely poor compile
time error messages: even if an interface is simple, the complicated
implementation details become visible when the user does something
wrong.</p>

<p>Template metaprogramming interferes with large scale refactoring by
making the job of refactoring tools harder. First, the template code
is expanded in multiple contexts, and it's hard to verify that the
transformation makes sense in all of them. Second, some refactoring
tools work with an AST that only represents the structure of the code
after template expansion. It can be difficult to automatically work
back to the original source construct that needs to be
rewritten.</p>

<p class="decision"></p>
<p>Template metaprogramming sometimes allows cleaner and easier-to-use
interfaces than would be possible without it, but it's also often a
temptation to be overly clever. It's best used in a small number of
low level components where the extra maintenance burden is spread out
over a large number of uses.</p>

<p>Think twice before using template metaprogramming or other
complicated template techniques; think about whether the average
member of your team will be able to understand your code well enough
to maintain it after you switch to another project, or whether a
non-C++ programmer or someone casually browsing the code base will be
able to understand the error messages or trace the flow of a function
they want to call.  If you're using recursive template instantiations
or type lists or metafunctions or expression templates, or relying on
SFINAE or on the <code>sizeof</code> trick for detecting function
overload resolution, then there's a good chance you've gone too
far.</p>

<p>If you use template metaprogramming, you should expect to put
considerable effort into minimizing and isolating the complexity. You
should hide metaprogramming as an implementation detail whenever
possible, so that user-facing headers are readable, and you should
make sure that tricky code is especially well commented. You should
carefully document how the code is used, and you should say something
about what the "generated" code looks like. Pay extra attention to the
error messages that the compiler emits when users make mistakes.  The
error messages are part of your user interface, and your code should
be tweaked as necessary so that the error messages are understandable
and actionable from a user point of view.</p>

<h3 id="Boost">Boost</h3>

<p>Use only approved libraries from the Boost library
collection.</p>

<p class="definition"></p>
<p> The
<a href="https://www.boost.org/">
Boost library collection</a> is a popular collection of
peer-reviewed, free, open-source C++ libraries.</p>

<p class="pros"></p>
<p>Boost code is generally very high-quality, is widely
portable, and fills many important gaps in the C++
standard library, such as type traits and better binders.</p>

<p class="cons"></p>
<p>Some Boost libraries encourage coding practices which can
hamper readability, such as metaprogramming and other
advanced template techniques, and an excessively
"functional" style of programming. </p>

<p class="decision"></p>



<div>
<p>In order to maintain a high level of readability for
all contributors who might read and maintain code, we
only allow an approved subset of Boost features.
Currently, the following libraries are permitted:</p>

<ul>
  <li>
  <a href="https://www.boost.org/libs/utility/call_traits.htm">
  Call Traits</a> from <code>boost/call_traits.hpp</code></li>

  <li><a href="https://www.boost.org/libs/utility/compressed_pair.htm">
  Compressed Pair</a> from  <code>boost/compressed_pair.hpp</code></li>

  <li><a href="https://www.boost.org/libs/graph/">
  The Boost Graph Library (BGL)</a> from <code>boost/graph</code>,
  except serialization (<code>adj_list_serialize.hpp</code>) and
   parallel/distributed algorithms and data structures
   (<code>boost/graph/parallel/*</code> and
   <code>boost/graph/distributed/*</code>).</li>

  <li><a href="https://www.boost.org/libs/property_map/">
  Property Map</a> from <code>boost/property_map</code>, except
  parallel/distributed property maps (<code>boost/property_map/parallel/*</code>).</li>

  <li><a href="https://www.boost.org/libs/iterator/">
  Iterator</a> from <code>boost/iterator</code></li>

  <li>The part of <a href="https://www.boost.org/libs/polygon/">
  Polygon</a> that deals with Voronoi diagram
  construction and doesn't depend on the rest of
  Polygon:
  <code>boost/polygon/voronoi_builder.hpp</code>,
  <code>boost/polygon/voronoi_diagram.hpp</code>, and
  <code>boost/polygon/voronoi_geometry_type.hpp</code></li>

  <li><a href="https://www.boost.org/libs/bimap/">
  Bimap</a> from <code>boost/bimap</code></li>

  <li><a href="https://www.boost.org/libs/math/doc/html/dist.html">
  Statistical Distributions and Functions</a> from
  <code>boost/math/distributions</code></li>

  <li><a href="https://www.boost.org/libs/math/doc/html/special.html">
  Special Functions</a> from <code>boost/math/special_functions</code></li>

  <li><a href="https://www.boost.org/libs/math/doc/html/root_finding.html">
  Root Finding Functions</a> from <code>boost/math/tools</code></li>

  <li><a href="https://www.boost.org/libs/multi_index/">
  Multi-index</a> from <code>boost/multi_index</code></li>

  <li><a href="https://www.boost.org/libs/heap/">
  Heap</a> from <code>boost/heap</code></li>

  <li>The flat containers from
  <a href="https://www.boost.org/libs/container/">Container</a>:
  <code>boost/container/flat_map</code>, and
  <code>boost/container/flat_set</code></li>

  <li><a href="https://www.boost.org/libs/intrusive/">Intrusive</a>
  from <code>boost/intrusive</code>.</li>

  <li><a href="https://www.boost.org/libs/sort/">The
  <code>boost/sort</code> library</a>.</li>

  <li><a href="https://www.boost.org/libs/preprocessor/">Preprocessor</a>
  from <code>boost/preprocessor</code>.</li>
</ul>

<p>We are actively considering adding other Boost
features to the list, so this list may be expanded in
the future.</p>
</div>



<h3 id="std_hash">std::hash</h3>

<p>Do not define specializations of <code>std::hash</code>.</p>

<p class="definition"></p>
<p><code>std::hash&lt;T&gt;</code> is the function object that the
C++11 hash containers use to hash keys of type <code>T</code>,
unless the user explicitly specifies a different hash function. For
example, <code>std::unordered_map&lt;int, std::string&gt;</code> is a hash
map that uses <code>std::hash&lt;int&gt;</code> to hash its keys,
whereas <code>std::unordered_map&lt;int, std::string, MyIntHash&gt;</code>
uses <code>MyIntHash</code>.</p>

<p><code>std::hash</code> is defined for all integral, floating-point,
pointer, and <code>enum</code> types, as well as some standard library
types such as <code>string</code> and <code>unique_ptr</code>. Users
can enable it to work for their own types by defining specializations
of it for those types.</p>

<p class="pros"></p>
<p><code>std::hash</code> is easy to use, and simplifies the code
since you don't have to name it explicitly. Specializing
<code>std::hash</code> is the standard way of specifying how to
hash a type, so it's what outside resources will teach, and what
new engineers will expect.</p>

<p class="cons"></p>
<p><code>std::hash</code> is hard to specialize. It requires a lot
of boilerplate code, and more importantly, it combines responsibility
for identifying the hash inputs with responsibility for executing the
hashing algorithm itself. The type author has to be responsible for
the former, but the latter requires expertise that a type author
usually doesn't have, and shouldn't need. The stakes here are high
because low-quality hash functions can be security vulnerabilities,
due to the emergence of
<a href="https://emboss.github.io/blog/2012/12/14/breaking-murmur-hash-flooding-dos-reloaded/">
hash flooding attacks</a>.</p>

<p>Even for experts, <code>std::hash</code> specializations are
inordinately difficult to implement correctly for compound types,
because the implementation cannot recursively call <code>std::hash</code>
on data members. High-quality hash algorithms maintain large
amounts of internal state, and reducing that state to the
<code>size_t</code> bytes that <code>std::hash</code>
returns is usually the slowest part of the computation, so it
should not be done more than once.</p>

<p>Due to exactly that issue, <code>std::hash</code> does not work
with <code>std::pair</code> or <code>std::tuple</code>, and the
language does not allow us to extend it to support them.</p>

<p class="decision"></p>
<p>You can use <code>std::hash</code> with the types that it supports
"out of the box", but do not specialize it to support additional types.
If you need a hash table with a key type that <code>std::hash</code>
does not support, consider using legacy hash containers (e.g.
<code>hash_map</code>) for now; they use a different default hasher,
which is unaffected by this prohibition.</p>

<p>If you want to use the standard hash containers anyway, you will
need to specify a custom hasher for the key type, e.g.</p>
<pre>std::unordered_map&lt;MyKeyType, Value, MyKeyTypeHasher&gt; my_map;
</pre><p>
Consult with the type's owners to see if there is an existing hasher
that you can use; otherwise work with them to provide one,
 or roll your own.</p>

<p>We are planning to provide a hash function that can work with any type,
using a new customization mechanism that doesn't have the drawbacks of
<code>std::hash</code>.</p>



<h3 id="Other_Features"><a name="C++11">Other C++ Features</a></h3>

<p>As with <a href="#Boost">Boost</a>, some modern C++
extensions encourage coding practices that hamper
readability&#8212;for example by removing
checked redundancy (such as type names) that may be
helpful to readers, or by encouraging template
metaprogramming. Other extensions duplicate functionality
available through existing mechanisms, which may lead to confusion
and conversion costs.</p>

<p class="decision"></p>
<p>In addition to what's described in the rest of the style
guide, the following C++ features may not be used:</p>

<ul>


  <li>Compile-time rational numbers
  (<code>&lt;ratio&gt;</code>), because of concerns that
  it's tied to a more template-heavy interface
  style.</li>

  <li>The <code>&lt;cfenv&gt;</code> and
  <code>&lt;fenv.h&gt;</code> headers, because many
  compilers do not support those features reliably.</li>

  <li>The <code>&lt;filesystem&gt;</code> header, which

  does not have sufficient support for testing, and suffers
  from inherent security vulnerabilities.</li>


</ul>

<h3 id="Nonstandard_Extensions">Nonstandard Extensions</h3>

<p>Nonstandard extensions to C++ may not be used unless otherwise specified.</p>

<p class="definition"></p>
<p>Compilers support various extensions that are not part of standard C++. Such
  extensions include GCC's <code>__attribute__</code>, intrinsic functions such
  as <code>__builtin_prefetch</code>, designated initializers (e.g.
  <code>Foo f = {.field = 3}</code>), inline assembly, <code>__COUNTER__</code>,
  <code>__PRETTY_FUNCTION__</code>, compound statement expressions (e.g.
  <code>foo = ({ int x; Bar(&amp;x); x })</code>, variable-length arrays and
  <code>alloca()</code>, and the "<a href="https://en.wikipedia.org/wiki/Elvis_operator">Elvis Operator</a>"
  <code>a?:b</code>.</p>

<p class="pros"></p>
  <ul>
    <li>Nonstandard extensions may provide useful features that do not exist
      in standard C++. For example, some people think that designated
      initializers are more readable than standard C++ features like
      constructors.</li>
    <li>Important performance guidance to the compiler can only be specified
      using extensions.</li>
  </ul>

<p class="cons"></p>
  <ul>
    <li>Nonstandard extensions do not work in all compilers. Use of nonstandard
      extensions reduces portability of code.</li>
    <li>Even if they are supported in all targeted compilers, the extensions
      are often not well-specified, and there may be subtle behavior differences
      between compilers.</li>
    <li>Nonstandard extensions add to the language features that a reader must
      know to understand the code.</li>
  </ul>

<p class="decision"></p>
<p>Do not use nonstandard extensions. You may use portability wrappers that
  are implemented using nonstandard extensions, so long as those wrappers

  are provided by a designated project-wide
  portability header.</p>

<h3 id="Aliases">Aliases</h3>

<p>Public aliases are for the benefit of an API's user, and should be clearly documented.</p>

<p class="definition"></p>
<p>There are several ways to create names that are aliases of other entities:</p>
<pre>typedef Foo Bar;
using Bar = Foo;
using other_namespace::Foo;
</pre>

  <p>In new code, <code>using</code> is preferable to <code>typedef</code>,
  because it provides a more consistent syntax with the rest of C++ and works
  with templates.</p>

  <p>Like other declarations, aliases declared in a header file are part of that
  header's public API unless they're in a function definition, in the private portion of a class,
  or in an explicitly-marked internal namespace. Aliases in such areas or in .cc files are
  implementation details (because client code can't refer to them), and are not restricted by this
  rule.</p>

<p class="pros"></p>
  <ul>
    <li>Aliases can improve readability by simplifying a long or complicated name.</li>
    <li>Aliases can reduce duplication by naming in one place a type used repeatedly in an API,
      which <em>might</em> make it easier to change the type later.
    </li>
  </ul>

<p class="cons"></p>
  <ul>
    <li>When placed in a header where client code can refer to them, aliases increase the
      number of entities in that header's API, increasing its complexity.</li>
    <li>Clients can easily rely on unintended details of public aliases, making
      changes difficult.</li>
    <li>It can be tempting to create a public alias that is only intended for use
      in the implementation, without considering its impact on the API, or on maintainability.</li>
    <li>Aliases can create risk of name collisions</li>
    <li>Aliases can reduce readability by giving a familiar construct an unfamiliar name</li>
    <li>Type aliases can create an unclear API contract:
      it is unclear whether the alias is guaranteed to be identical to the type it aliases,
      to have the same API, or only to be usable in specified narrow ways</li>
  </ul>

<p class="decision"></p>
<p>Don't put an alias in your public API just to save typing in the implementation;
  do so only if you intend it to be used by your clients.</p>
<p>When defining a public alias, document the intent of
the new name, including whether it is guaranteed to always be the same as the type
it's currently aliased to, or whether a more limited compatibility is
intended. This lets the user know whether they can treat the types as
substitutable or whether more specific rules must be followed, and can help the
implementation retain some degree of freedom to change the alias.</p>
<p>Don't put namespace aliases in your public API. (See also <a href="#Namespaces">Namespaces</a>).
</p>

<p>For example, these aliases document how they are intended to be used in client code:</p>
<pre>namespace mynamespace {
// Used to store field measurements. DataPoint may change from Bar* to some internal type.
// Client code should treat it as an opaque pointer.
using DataPoint = foo::Bar*;

// A set of measurements. Just an alias for user convenience.
using TimeSeries = std::unordered_set&lt;DataPoint, std::hash&lt;DataPoint&gt;, DataPointComparator&gt;;
}  // namespace mynamespace
</pre>

<p>These aliases don't document intended use, and half of them aren't meant for client use:</p>

<pre class="badcode">namespace mynamespace {
// Bad: none of these say how they should be used.
using DataPoint = foo::Bar*;
using std::unordered_set;  // Bad: just for local convenience
using std::hash;           // Bad: just for local convenience
typedef unordered_set&lt;DataPoint, hash&lt;DataPoint&gt;, DataPointComparator&gt; TimeSeries;
}  // namespace mynamespace
</pre>

<p>However, local convenience aliases are fine in function definitions, private sections of
  classes, explicitly marked internal namespaces, and in .cc files:</p>

<pre>// In a .cc file
using foo::Bar;
</pre>

<h2 id="Naming">Именование</h2>

<p>Основные правила стиля кодирования приходятся на именование. 
Вид имени сразу же (без поиска объявления) говорит нам что это: тип, переменная, функция, константа, макрос и т.д.</p>

<p>Правила именования могут быть произвольными, однако важна их согласованность, и правилам нужно следовать.</p>

<h3 id="General_Naming_Rules">Общие принципы именования</h3>

<p>Используйте имена, который будут понятны даже людям из другой команды.</p>

<p>Имя должно говорить о цели или применимости объекта.
Не экономьте на длине имени, лучше более длинное и более понятное (даже новичкам) имя.
Поменьше аббревиатур, особенно если они незнакомы вне проекта.
Используйте только известные аббревиатуры (Википедия о них знает?).
Не сокращайте слова.
В целом, длина имени должна соответствовать размеру области видимости.
Например, <code>n</code> - подходящее имя внутри функции в 5 строк,
однако при описании класса это может быть коротковато.</p>

<pre>class MyClass {
 public:
  int CountFooErrors(const std::vector&lt;Foo&gt;&amp; foos) {
    int n = 0;  // Чёткий смысл для небольшой области видимости
    for (const auto&amp; foo : foos) {
      ...
      ++n;
    }
    return n;
  }
  void DoSomethingImportant() {
    std::string fqdn = ...;  // Известная аббревиатура полного доменного имени
  }
 private:
  const int kMaxAllowedConnections = ...;  // Чёткий смысл для контекста
};
</pre>

<pre class="badcode">class MyClass {
 public:
  int CountFooErrors(const std::vector&lt;Foo&gt;&amp; foos) {
    int total_number_of_foo_errors = 0;  // Слишком подробное имя для короткой функции
    for (int foo_index = 0; foo_index &lt; foos.size(); ++foo_index) {  // Лучше использовать `i`
      ...
      ++total_number_of_foo_errors;
    }
    return total_number_of_foo_errors;
  }
  void DoSomethingImportant() {
    int cstmr_id = ...;  // Сокращённое слово (удалены буквы)
  }
 private:
  const int kNum = ...;  // Для целого класса очень нечёткое имя
};
</pre>

<p>Отметим, что типовые имена также допустимы: 
<code>i</code> для итератора или счётчика, <code>T</code> для параметра шаблона.</p>

<p>В дальнейшем при описании правил "word" / "слово" это всё, что пишется 
на английском без пробелов, в том числе и аббревиатуры.
В слове первая буква может быть заглавной (зависит от стиля:
 "<a href="https://en.wikipedia.org/wiki/Camel_case">camel
case</a>" или "Pascal case"),
 остальные буквы - строчные. Например, предпочтительно <code>StartRpc()</code>, нежелательно
<code>StartRPC()</code>.</p>

<p>Параметры шаблона также следуют правилам своих категорий:
<a href="#Type_Names">type names / имена типов</a> для типов, 
<a href="#Variable_Names">variable names / имена переменных</a> для переменных.

</p><h3 id="File_Names">Имена файлов</h3>

<p>Имена файлов должны быть записаны только строчными буквами,
для разделения можно использовать подчёркивание (<code>_</code>) или дефис (<code>-</code>).
Используйте тот разделитель, который используется в проекте. Если единого подхода нет - используйте "_".</p>

<p>Примеры подходящих имён:</p>

<ul>
  <li><code>my_useful_class.cc</code></li>
  <li><code>my-useful-class.cc</code></li>
  <li><code>myusefulclass.cc</code></li>
  <li><code>myusefulclass_test.cc // _unittest and _regtest are deprecated.</code></li>
</ul>

<p>C++ файлы должны заканчиваться на <code>.cc</code>, заголовочные - на
<code>.h</code>. Файлы, включаемые как текст должны заканчиваться
на <code>.inc</code> (см. также секцию 
<a href="#Self_contained_Headers">Независимые заголовочные файлы</a>).</p>

<p>Не используйте имена, уже существующие в 
<code>/usr/include</code>, такие как <code>db.h</code>.</p>

<p>Старайтесь давать файлам специфичные имена.
Например, <code>http_server_logs.h</code> лучше чем
<code>logs.h</code>.
Когда файлы используются парами, лучше давать им одинаковые имена.
Например, <code>foo_bar.h</code> и
<code>foo_bar.cc</code> (и содержат класс <code>FooBar</code>).</p>

<h3 id="Type_Names">Имена типов</h3>

<p>Имена типов начинаются с прописной буквы, каждое новое слово также начинается с прописной буквы.
 Подчёркивания не используются:
<code>MyExcitingClass</code>, <code>MyExcitingEnum</code>.</p>

<p>Имена всех типов - классов, структур, псевдонимов, перечислений, параметров шаблонов - именуются в одинаковом стиле.
 Имена типов начинаются с прописной буквы, каждое новое слово также начинается с прописной буквы.
 Подчёркивания не используются. Например:</p>

<pre>// classes and structs
class UrlTable { ...
class UrlTableTester { ...
struct UrlTableProperties { ...

// typedefs
typedef hash_map&lt;UrlTableProperties *, std::string&gt; PropertiesMap;

// using aliases
using PropertiesMap = hash_map&lt;UrlTableProperties *, std::string&gt;;

// enums
enum UrlTableErrors { ...
</pre>

<h3 id="Variable_Names">Имена переменных</h3>

<p>Имена переменных (включая параметры функций) и
 членов данных пишутся строчными буквами с подчёркиванием между словами.
 Члены данных классов (не структур) дополняются подчёркиванием в конце имени.
 Например:
<code>a_local_variable</code>, <code>a_struct_data_member</code>,
<code>a_class_data_member_</code>.</p>

<h4>Имена обычных переменных</h4>

<p>Например:</p>

<pre>std::string table_name;  // OK - строчные буквы с подчёркиванием
</pre>

<pre class="badcode">std::string tableName;   // Плохо - смешанный стиль
</pre>

<h4>Члены данных класса</h4>

<p>Члены данных классов, статические и нестатические,
 именуются как обычные переменные с добавлением подчёркивания в конце.</p>

<pre>class TableInfo {
  ...
 private:
  std::string table_name_;  // OK - подчёркивание в конце
  static Pool&lt;TableInfo&gt;* pool_;  // OK.
};
</pre>

<h4>Члены данных структуры</h4>

<p>Члены данных структуры, статические и нестатические,
 именуются как обычные переменные. К ним не добавляется символ подчёркивания в конце.</p>

<pre>struct UrlTableProperties {
  std::string name;
  int num_entries;
  static Pool&lt;UrlTableProperties&gt;* pool;
};
</pre>


<p>См. также <a href="#Structs_vs._Classes">Структуры vs
Классы</a>, где описано когда использовать структуры, когда классы.</p>

<h3 id="Constant_Names">Имена констант</h3>

<p>Объекты объявляются как constexpr или const, чтобы значение не менялось
 в процессе выполнения. Имена констант начинаются с символа "k",
 далее идёт имя в смешанном стиле (прописные и строчные буквы).
 Подчёркивание может быть использовано в редких случаях когда прописные буквы
 не могут использоваться для разделения. Например:</p>

<pre>const int kDaysInAWeek = 7;
const int kAndroid8_0_0 = 24;  // Android 8.0.0
</pre>

<p>Все аналогичные константные объекты со статическим типом хранилища
 (т.е. статические или глобальные, подробнее тут:
 <a href="http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration">
Storage Duration</a>) именуются также. Это соглашение является необязательным 
для переменных в других типах хранилища (например, автоматические константные объекты).</p>

<h3 id="Function_Names">Имена функций</h3>

<p>Обычные функции именуются в смешанном стиле (прописные и строчные буквы);
 функции доступа к переменным (accessor и mutator) должны иметь стиль, похожий на целевую переменную.</p>

<p>Обычно имя функции начинается с прописной буквы и каждое слово в имени пишется с прописной буквы.</p>

<pre>AddTableEntry()
DeleteUrl()
OpenFileOrDie()
</pre>

<p>(Аналогичные правила применяются для констант в области класса или пространства имён (namespace)
 которые представляют собой часть API и должны выглядеть как функции (и то, что они не функции - некритично))</p>

<p>Accessor-ы и mutator-ы (функции get и set) могут именоваться наподобие соответствующих переменных.
 Они часто соответствуют реальным переменным-членам, однако это не обязательно.
 Например, <code>int count()</code> и <code>void
set_count(int count)</code>.</p>

<h3 id="Namespace_Names">Именование пространства имён (namespace)</h3>
<p>Пространство имён называется строчными буквами. Пространство имён 
 верхнего уровня основывается на имени проекта.
 Избегайте коллизий ваших имён и других, хорошо известных, пространств имён.</p>

<p>Пространство имён верхнего уровня - это обычно название проекта
 или команды (которая делала код). Код должен располагаться в директории
 (или поддиректории) с именем, соответствующим пространству имён.</p>


<p>Не забывайте правило <a href="#General_Naming_Rules">не использовать аббревиатуры</a>
 - к пространствам имён это также применимо. Коду внутри вряд ли потребуется упоминание
 пространства имён, поэтому аббревиатуры - это лишнее.</p>

<p>Избегайте использовать для вложенных пространств имён известные названия.
 Коллизии между именами могут привести к сюрпризам при сборке. В частности,
 не создавайте вложенных пространств имён с именем <code>std</code>.
 Рекомендуются уникальные идентификаторы проекта
(<code>websearch::index</code>, <code>websearch::index_util</code>)
 вместо небезопасных к коллизиям <code>websearch::util</code>.</p>

<p>Для <code>internal / внутренних</code> пространств имён коллизии
 могут возникать при добавлении другого кода
 (внутренние хелперы имеют свойство повторяться у разных команд).
 В этом случае хорошо помогает использование имени файла для
 именования пространства имён.
(<code>websearch::index::frobber_internal</code> для использования в 
<code>frobber.h</code>)</p>

<h3 id="Enumerator_Names">Имена перечислений</h3>

<p>Перечисления (как с ограничениями на область видимости (scoped),
 так и без (unscoped)) должны
 именоваться <i>либо</i> как <a href="#Constant_Names">константы</a>,
 либо как <a href="#Macro_Names">macros</a>. Т.е.: либо <code>kEnumName</code>, либо
<code>ENUM_NAME</code>.</p>

<p>Предпочтительно именовать отдельные значения в перечислителе как
 <a href="#Constant_Names">константы</a>. Однако, допустимо
 именовать как <a href="#Macro_Names">макросы</a>.  Имя самого перечисления
<code>UrlTableErrors</code> (и
<code>AlternateUrlTableErrors</code>), это тип. Следовательно, используется смешанный стиль.</p>

<pre>enum UrlTableErrors {
  kOk = 0,
  kErrorOutOfMemory,
  kErrorMalformedInput,
};
enum AlternateUrlTableErrors {
  OK = 0,
  OUT_OF_MEMORY = 1,
  MALFORMED_INPUT = 2,
};
</pre>

<p>Вплоть до января 2009 года стиль именования значений
 перечисления был как у <a href="#Macro_Names">макросов</a>. 
 Это создавало проблемы дублирования имён макросов 
 и значений перечислений. Применение стиля констант решает
 проблему и в новом коде предпочтительно использовать стиль
 констант. Однако, старый код нет необходимости переписывать
 (пока нет проблем дублирования).</p>



<h3 id="Macro_Names">Имена макросов</h3>

<p>Вы ведь не собираетесь <a href="#Preprocessor_Macros">определять
 макросы</a>? На всякий случай (если собираетесь), они должны выглядеть так:
<code>MY_MACRO_THAT_SCARES_SMALL_CHILDREN_AND_ADULTS_ALIKE</code>.
</p>

<p>Пожалуйста прочтите как <a href="#Preprocessor_Macros">
определять макросы</a>; Обычно, макросы <em>не</em> должны использоваться.
Однако, если они вам абсолютно необходимы, именуйте их
прописными буквами с символами подчёркивания.</p>

<pre>#define ROUND(x) ...
#define PI_ROUNDED 3.0
</pre>

<h3 id="Exceptions_to_Naming_Rules">Исключения из правил именования</h3>

<p>Если вам нужно именовать что-то, имеющее аналоги в существующем
C или C++ коде, то следуйте используемому в коде стилю.</p>

<dl>
  <dt><code>bigopen()</code></dt>
  <dd>имя функции, образованное от <code>open()</code></dd>

  <dt><code>uint</code></dt>
  <dd>похож на стандартный тип</dd>

  <dt><code>bigpos</code></dt>
  <dd><code>struct</code> или <code>class</code>, образованный от <code>pos</code></dd>

  <dt><code>sparse_hash_map</code></dt>
  <dd>STL-подобная сущность; следуйте стилю STL</dd>

  <dt><code>LONGLONG_MAX</code></dt>
  <dd>константа, такая же как <code>INT_MAX</code></dd>
</dl>

<h2 id="Comments">Комментарии</h2>

<p>Комментарии являются обязательными для кода (если вы планируете его читать). Следующие правила
 описывают, что вы должны комментировать и как. Но помните: хотя комментарии очень важны, идеальный код
 сам себя документирует. Использование "говорящих" имён для типов и переменных намного лучше, чем непонятные 
 имена, которые потом требуется расписывать в комментариях.</p>

<p>Комментируйте код с учётом его следующих читателей: программистов, которым потребуется разбираться в вашем коде.
 Учтите, что следующим читателем можете стать вы!</p>

<h3 id="Comment_Style">Стиль комментариев</h3>

<p>Используйте либо <code>//</code> либо <code>/* */</code>, пока не нарушается единообразие.</p>

<p>Вы можете использовать либо <code>//</code> либо <code>/*
*/</code>, однако <code>//</code> <em>намного</em> предпочтительнее. Однако, всегда согласовывайте
 ваш стиль комментариев с уже существующим кодом.</p>

<h3 id="File_Comments">Комментарии в шапке файла</h3>

<div>
<p>В начало каждого файла вставляйте шапку с лицензией.</p>
</div>

<p>Комментарии в файле должны описывать его содержимое. Если файл объявляет,
 описывает или тестирует одну абстракцию (на которую уже есть комментарий),
 дополнительное описание в шапке файла не нужно. В ином случае, в начало файла
 вставляйте описание содержимого.</p>

<h4>Правовая информация и список авторов</h4>

<div>
<p>Каждый файл должен содержать информацию о лицензии. Формат описания зависит
 от лицензии, используемой в проекте. У каждой лицензии (Apache 2.0,
BSD, LGPL, GPL, др.) могут быть свои требования к оформлению.</p>
</div>

<p>Если вы делаете значительные изменения в файле, подумайте над удалением
 прежнего списка авторов. Обновлённые файлы могут уже не содержать
 упоминание об авторских правах и список авторов.</p>

<h4>Содержимое файлов</h4>

<p>Если <code>.h</code> объявляет несколько абстракций, комментарий в шапке файла
 должен в целом описывать содержимое файла и как абстракции связаны друг с другом.
 Одного, двух предложений в комментарии обычно достаточно. Более детальная информация
 расписывается в другом месте (не в шапке файла).</p>

<p>Не дублируйте комментарии в <code>.h</code> и <code>.cc</code> файлах - со временем
 комментарии становятся разными.</p>

<h3 id="Class_Comments">Комментарии класса</h3>

<p>Каждое объявление класса (кроме совсем очевидных) должно сопровождаться
 комментарием, для чего класс и как им пользоваться.</p>

<pre>// Перебор содержимого GargantuanTable.
// Пример:
//    GargantuanTableIterator* iter = table-&gt;NewIterator();
//    for (iter-&gt;Seek("foo"); !iter-&gt;done(); iter-&gt;Next()) {
//      process(iter-&gt;key(), iter-&gt;value());
//    }
//    delete iter;
class GargantuanTableIterator {
  ...
};
</pre>

<p>Комментарий к классу должен быть достаточным для понимания: как и когда использовать
 класс, дополнительные требования для правильного использования класса.
 Описывайте, если требуется, ограничения (предположения) на синхронизацию в классе.
 Если экземпляр класса может использоваться из разных потоков, обязательно распишите
 правила многопоточного использования.</p>

<p>В комментарии к классу также можно привести короткие примеры кода, показывающие
 как проще использовать класс.</p>

<p>Обычно класс объявляется/определяется в разных файлах (<code>.h</code> и <code>.cc</code>).
 Комментарии, описывающие использование класса должны быть рядом с определением интерфейса.
 Комментарии о тонкостях реализации должны быть рядом с кодом самих методов.</p>

<h3 id="Function_Comments">Комментарии функции</h3>

<p>Комментарии к объявлению функции должны описывать использование функции (кроме
 самых очевидных случаев). Комментарии к определению функции описывают реализацию.</p>

<h4>Объявление функции</h4>

<p>Объявление каждой функции должно иметь комментарий (прямо перед объявлением), что
 функция делает и как ей пользоваться. Комментарий можно опустить, только если 
 функция простая и использование очевидно (например, функции вычитывания значений 
 переменных). Старайтесь начинать комментарии в изъявительном наклонении ("Открывает файл").
 Использование повелительного наклонение ("Открыть файл") - не рекомендуется. Комментарий
 описывает суть функции, а не то, как она это делает.</p>

<p>В комментарии к объявлению функции обратите внимание на следующее:</p>

<ul>
  <li>Что подаётся на вход функции, что возвращается в результате.</li>

  <li>Для функции-члена класса: сохраняет ли экземпляр ссылки на аргументы,
 нужно ли освобождать память.</li>

  <li>Выделяет ли функция память, которую должен удалить вызывающий код.</li>

  <li>Могут ли быть аргументы nullptr.</li>

  <li>Сложность (алгоритмическая) функции.</li>

  <li>Допустим ли одновременный вызов из разных потоков. Что с синхронизацией?</li>
 </ul>

<p>Пример:</p>

<pre>// Возвращает итератор по таблице. Клиент должен удалить 
// итератор после использования. Нельзя использовать итератор
// если соответствующий объект GargantuanTable был удалён.
//
// Итератор изначально указывает на начало таблицы.
//
// Этот метод эквивалентен следующему:
//    Iterator* iter = table-&gt;NewIterator();
//    iter-&gt;Seek("");
//    return iter;
// Если вы собираетесь сразу же делать новую операцию поиска,
// быстрее будет вызвать NewIterator() и избежать лишней операции поиска.
Iterator* GetIterator() const;
</pre>

<p>Однако не стоит разжёвывать очевидные вещи.</p>

<p>Когда документируйте перегружаемые функции, делайте основной упор
на изменениях по сравнению с исходной функцией. А если изменений нет
(что бывает часто), то дополнительные комментарии вообще не нужны.</p>

<p>Комментируя конструкторы и деструкторы, учитывайте, что
 читатель кода знает их назначение. Поэтому комментарий
типа "разрушает этот объект" - бестолковый. Можете описывать,
что конструктор делает с аргументами (например, изменение владения на указатели)
или какие именно операции по очистке делает деструктор.
Если всё и так понятно - ничего не комментируйте. Вообще,
обычно деструкторы не имеют комментариев (при объявлении).</p>

<h4>Определение функций</h4>

<p>Если есть какие-то хитрости в реализации функции, то можно
к определению добавить объяснительный комментарий. В нём можно
описать трюки с кодом, дать обзор всех этапов вычислений,
объяснить выбор той или иной реализации (особенно если есть
более лучшие альтернативы). Можете описать принципы синхронизации
кусков кода (здесь блокируем, а здесь рыбу заворачиваем).</p>

<p>Отметим что вы <em>не должны</em> повторять комментарий из
объявления функции (из <code>.h</code> файла или т.п.).
Можно кратко описать, что функция делает, однако основной упор
должен быть <em>как</em> она это делает.</p>

<h3 id="Variable_Comments">Комментарии к переменным</h3>

<p>По хорошему, имя переменной должно сразу говорить что это и зачем.
Однако, в некоторых случаях требуются дополнительные комментарии.</p>

<h4>Член данных класса</h4>

<p>Назначение каждого члена класса должно быть очевидно. Если есть
неочевидные тонкости (специальные значения, завязки с другими членами, ограничения
по времени жизни) - всё это нужно комментировать. Однако, если типа и имени
достаточно - комментарии добавлять не нужно.</p>

<p>С другой стороны, полезными будут описания особых (и неочевидных)
значений (nullptr или -1). Например:</p>

<pre>private:
 // Используется для проверки выхода за границы
 // -1 - показывает, что мы не знаем сколько записей в таблице
 int num_total_entries_;
</pre>

<h4>Глобальные переменные</h4>

<p>Ко всем глобальным переменным следует писать комментарий о их
назначении и (если не очевидно) почему они должны быть глобальными.
Например:</p>

<pre>// Общее количество тестов, прогоняемых в регрессионом тесте
const int kNumTestCases = 6;
</pre>

<h3 id="Implementation_Comments">Комментарии к реализации</h3>

<p>Комментируйте реализацию функции или алгоритма в случае
наличия неочевидных, интересных, важных кусков кода.</p>

<h4>Описательные комментарии</h4>

<p>Блоки кода, отличающиеся сложностью или нестандартностью,
должны предваряться комментарием. Например:</p>

<pre>// Делим результат на 2. Переменная x содержит флаг переноса
for (int i = 0; i &lt; result-&gt;size(); ++i) {
  x = (x &lt;&lt; 8) + (*result)[i];
  (*result)[i] = x &gt;&gt; 1;
  x &amp;= 1;
}
</pre>

<h4>Построчные комментарии</h4>

<p>Строки кода с неочевидным смыслом желательно дополнять комментарием (обычно располагаемым в конце строки).
Этот комментраий должен отделяться от кода 2-мя проблами. Например:</p>

<pre>// Мапируем блок данных, если объём позволяет
mmap_budget = max&lt;int64&gt;(0, mmap_budget - index_-&gt;length());
if (mmap_budget &gt;= data_size_ &amp;&amp; !MmapData(mmap_chunk_bytes, mlock))
  return;  // Ошибку уже логировали
</pre>

<p>Отметим, что здесь 2 комментария на блок кода: один описывает что код делает,
другой напоминает, что ошибка уже в логе, если идёт возврат из функции.</p>

<h4 id="Function_Argument_Comments" class="stylepoint_subsection">Комментарии к аргументам функций</h4>

<p>Когда назначение аргумента функции неочевидно, подумайте о следующих вариантах:</p>

<ul>
  <li>Если аргумент есть фиксированное значение (literal constant) и это значение
  используется в разных блоках кода (и подразумевается, что это значение суть одно и тоже),
  вам следует создать константу и явно использовать её.</li>

  <li>Возможно следует заменить аргумент типа <code>bool</code> на
  перечисление (<code>enum</code>). Это сделает аргумент само-определяющим.</li>

  <li>Для функций, использующих несколько конфигурационных опций в аргументах, можно
  создать отдельный класс (или структуру), объединяющий все опции. И передавать в функцию
  экземпляр этого класса.
  Такой подход имеет несколько преимуществ: опции обозначаются именами, что объясняет
  их назначение. Уменьшается количество аргументов в функции - код легче писать и читать.
  И если вам понадобится добавить ещё опций, менять сам вызов функции не придётся.
  </li>

  <li>Вместо сложных выражений в аргументах используйте промежуточную переменную, которой присвойте выражение.</li>

  <li>В крайнем случае пишите комментарии в месте вызова для прояснения назначения аргументов.</li>
</ul>

    <p>Рассмотрим примеры:</p>

<pre class="badcode">// И какое назначение аргументов?
const DecimalNumber product = CalculateProduct(values, 7, false, nullptr);
</pre>

<p>Попробуем причесать код:</p>

<pre>ProductOptions options;
options.set_precision_decimals(7);
options.set_use_cache(ProductOptions::kDontUseCache);
const DecimalNumber product =
    CalculateProduct(values, options, /*completion_callback=*/nullptr);
</pre>

<h4 id="Implementation_Comment_Donts">Что делать не нужно</h4>

<p>Не объясняйте очевидное. В частности, не нужно объяснять вещи, очевидные для
человека, знающего C++. Вместо этого, можно описать <i>зачем</i>
этот код делает так (или вообще сделайте код само-описываемым).</p>

    <p>Сравним:</p>

<pre class="badcode">// Ищём элемент в векторе.  &lt;-- Плохо: очевидно же!
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</pre>

    <p>С этим:</p>

<pre>// Обрабатывает (Process) "element" пока есть хоть один
auto iter = std::find(v.begin(), v.end(), element);
if (iter != v.end()) {
  Process(element);
}
</pre>

    <p>Само-описывающий код вообще не нуждается в комментариях.
Комментарий на код выше может быть вообще очевидным (и не нужным):</p>

<pre>if (!IsAlreadyProcessed(element)) {
  Process(element);
}
</pre>

<h3 id="Punctuation,_Spelling_and_Grammar">Пунктуация, орфография и грамматика</h3>

<p>Обращайте внимание на пунктуацию, орфографию и грамматику: намного проще читать
грамотно написанные комментарии.</p>

<p>Комментарии должны быть написаны как рассказ: с правильной расстановкой прописных
букв и знаков препинания. В большинстве случаев законченные предложения легче понимаются,
нежели обрывки фраз. Короткие комментарии, такого типа как построчные, могут быть
менее формальными, но всё равно должны следовать общему стилю.</p>

<p>Хотя излишнее внимание код-ревьюера к использованию запятых вместо точек с запятой
может слегка раздражать, очень важно поддерживать высокий уровень читабельности и
понятности кода. Правильная пунктуация, орфография и грамматика этому очень сильно способствует.</p>

<h3 id="TODO_Comments">Комментарии TODO</h3>

<p>Используйте комментарии <code>TODO</code> для временного кода 
или достаточно хорошего (промежуточного, не идеального) решения.</p>

<p>Комментарий должен включать строку
<code>TODO</code> (все буквы прописные), за ней имя, адрес e-mail, ID дефекта или другая
информация для идентификации разработчика и сущности проблемы, для которой написан <code>TODO</code>.
Цель такого описания - возможность потом найти больше деталей.
Наличие <code>TODO</code> с описанием не означает, что указанный программист
исправит проблему. Поэтому, когда вы создаёте <code>TODO</code>, обычно
там указано Ваше имя.</p>

<div>
<pre>// TODO(kl@gmail.com): Используйте "*" для объединения.
// TODO(Zeke) Изменить для связывания.
// TODO(bug 12345): удалить фунционал "Последний посетитель".
</pre>
</div>

<p>Если ваш <code>TODO</code> вида "В будущем сделаем по-другому", то
указывайте либо конкретную дату ("Исправить в ноябре 2005"), либо событие
("Удалить тот код, когда все клиенты будут обрабатывать XML запросы").</p>

<h2 id="Formatting">Форматирование</h2>

<p>Стиль кодирования и форматирования являются вещью произвольной, однако проект
 намного легче управляется, если все следуют одному стилю. Хотя кто-то может 
 не соглашаться со всеми правилами (или пользоваться тем, чем привыкли), очень
 важно чтобы все следовали единым правилам, чтобы легко читать и понимать чужой код.</p>

<div>
<p>Для корректного форматирования мы создали 
<a href="https://evgenykislov.com/wp-content/custom/cpp_codestyle/google-c-style.el">
файл настроек для emacs</a>.</p>
</div>

<h3 id="Line_Length">Длина строк</h3>

<p>Желательно ограничивать длину строк кода 80-ю символами.</p>

<div>
<p>Это правило немного спорное, однако масса уже существющего кода 
придерживается этого принципа, и мы также поддерживаем его.</p>
</div>

<p class="pros"></p>
<p>Приверженцы правила утверждают, что строки длиннее не нужны, 
а постоянно подгонять размеры окон утомительно. Кроме того, некоторые 
размещают окна с кодом рядом друг с другом и не могут 
произвольно увеличивать ширину окон. При этом ширина в 80 символов 
- исторический стандарт, зачем его менять?.
</p>

<p class="cons"></p>
<p>Другая сторона утверждает, что длинные строки могут улучшить читабельность кода.
80 символов - пережиток мейнфреймов 1960-х. Современные экраны вполне могут показывать 
более длинные строки.</p>

<p class="decision"></p>
<p>80 символов - максимум.</p>

<p>Строка может превышать предел в 80 символов если:</p>

<ul>
  <li>комментарий при разделении потеряет в понятности или лёгкости копирования. Например,
  комментарий с примером команды или URL-ссылкой, длиннее 80 символов.</li>

  <li>строковый литерал/имя, длиной более 80 символов. Исключением является тестовый код, который желательно размещать в начале файла.</li>

  <li>выражения с include.</li>

  <li><a href="#The__define_Guard">Блокировка от повторного включения</a></li>

  <li>using декларации</li>
</ul>

<h3 id="Non-ASCII_Characters">Не-ASCII символы</h3>

<p>Не-ASCII символы следует использоваться как можно реже, кодировка должна быть UTF-8.</p>

<p>Вы не должны хардкодить строки для показа пользователю (даже английские),
поэтому Не-ASCII символы должны быть редкостью. Однако, в ряде случаев 
допустимо включать такие слова в код. Например, если код парсит файлы данных (с неанглийской  кодировкой),
возможно включать в код национальные слова-разделители.
В более общем случае, код юнит-тестов может содержать национальные строки.
В этих случаях следует использовать кодировку UTF-8, т.к. она понятна 
большинству утилит (которые понимают не только ASCII).</p>

<p>Кодировка hex также допустима, особенно если она улучшает читабельность. Например,
<code>"\xEF\xBB\xBF"</code> или 
<code>u8"\uFEFF"</code> - неразрывный пробел нулевой длины в Юникоде,
 и который не должен отображаться в правильном UTF-8 тексте.</p>

<p>Используйте префикс <code>u8</code> чтобы литералы вида
<code>\uXXXX</code> кодировались в UTF-8.
Не используйте его для строк, содержащих не-ASCII символы 
 уже закодированные в UTF-8 - можете получить корявый 
 текст если компилятор не распознает исходный код как UTF-8. </p>

<p>Избегайте использования символов C++11 <code>char16_t</code> и
<code>char32_t</code> т.к. они нужны для не-UTF-8 строк. По тем же причинам
 не используйте <code>wchar_t</code> (кроме случаев работы с Windows API,
 использующий <code>wchar_t</code>).</p>

<h3 id="Spaces_vs._Tabs">Пробелы против Табуляции</h3>

<p>Используйте только пробелы для отступов. 2 пробела на один отступ.</p>

<p>Мы используем пробелы для отступов. Не используйте табуляцию в своём
 коде - настройте свой редактор на вставку пробелов при нажатии клавиши Tab.</p>

<h3 id="Function_Declarations_and_Definitions">Объявления и определения функций</h3>

<p>Старайтесь размещать тип возвращаемого значения, имя функции и её параметры 
на одной строке (если всё умещается). Разбейте слишком длинный список параметров 
на строки также как аргументы в <a href="#Function_Calls">вызове функции</a>.</p>

<p>Пример правильного оформления функции:</p>


<pre>ReturnType ClassName::FunctionName(Type par_name1, Type par_name2) {
  DoSomething();
  ...
}
</pre>

<p>В случае если одной строки мало:</p>

<pre>ReturnType ClassName::ReallyLongFunctionName(Type par_name1, Type par_name2,
                                             Type par_name3) {
  DoSomething();
  ...
}
</pre>

<p>или, если первый параметр также не помещается:</p>

<pre>ReturnType LongClassName::ReallyReallyReallyLongFunctionName(
    Type par_name1,  // Отступ 4 пробела
    Type par_name2,
    Type par_name3) {
  DoSomething();  // Отступ 2 пробела
  ...
}
</pre>

<p>Несколько замечаний:</p>

<ul>
  <li>Выбирайте хорошие имена для параметров.</li>

  <li>Имя параметра можно опустить, если он не используется в определении функции.</li>

  <li>Если тип возвращаемого значения и имя функции не помещаются в одной строке, 
    тип оставьте на одной строке, имя функции перенесите на следующую. В этом случае
    не делайте дополнительный отступ перед именем функции.</li>

  <li>Открывающая круглая скобка всегда находится на одной строке с именем функции.</li>

  <li>Не вставляйте пробелы между именем функции и открывающей круглой скобкой.</li>

  <li>Не вставляйте пробелы между круглыми скобками и параметрами.</li>

  <li>Открывающая фигурная скобка всегда в конце последней строки определения.
     Не переносите её на новую строку.</li>

  <li>Закрывающая фигурная скобка располагается либо на отдельной строке,
     либо на той же строке, где и открывающая скобка.</li>

  <li>Между закрывающей круглой скобкой и открывающей фигурной скобкой должен быть пробел.</li>

  <li>Старайтесь выравнивать все параметры.</li>

  <li>Стандартный отступ - 2 пробела.</li>

  <li>При переносе параметров на другую строку используйте отступ 4 пробела.</li>
</ul>

<p>Можно опустить имя неиспользуемых параметров, если это очевидно из контекста:</p>

<pre>class Foo {
 public:
  Foo(const Foo&amp;) = delete;
  Foo&amp; operator=(const Foo&amp;) = delete;
};
</pre>

<p>Неиспользуемый параметры с неочевидным контекстом следует закомментировать
 в определении функции:</p>

<pre>class Shape {
 public:
  virtual void Rotate(double radians) = 0;
};

class Circle : public Shape {
 public:
  void Rotate(double radians) override;
};

void Circle::Rotate(double /*radians*/) {}
</pre>

<pre class="badcode">// Плохой стиль - если кто-то потом захочет изменить реализацию функции,
// назначение параметра не ясно.
void Circle::Rotate(double) {}
</pre>

<p>Атрибуты и макросы старайтесь использовать в начале обьявления или определения функции,
 до типа возвращаемого значения:</p>
<pre>ABSL_MUST_USE_RESULT bool IsOk();
</pre>

<h3 id="Formatting_Lambda_Expressions">Лямбды</h3>

<p>Форматируйте параметры и тело выражения аналогично обычной функции,
 список захватываемых переменных - как обычный список.</p>

<p>Для захвата переменных по ссылке не ставьте пробел между амперсандом (&amp;) и именем переменной.</p>
<pre>int x = 0;
auto x_plus_n = [&amp;x](int n) -&gt; int { return x + n; }
</pre>
<p>Короткие лямбды можно использовать напрямую как аргумент функции.</p>
<pre>std::set&lt;int&gt; blacklist = {7, 8, 9};
std::vector&lt;int&gt; digits = {3, 9, 1, 8, 4, 7, 1};
digits.erase(std::remove_if(digits.begin(), digits.end(), [&amp;blacklist](int i) {
               return blacklist.find(i) != blacklist.end();
             }),
             digits.end());
</pre>

<h3 id="Floating_Literals">Числа с плавающей запятой</h3>

<p>Числа с плавающей запятой всегда должны быть с десятичной точкой и 
 числами по обе стороны от неё (даже в случае экспоненциальной нотации). Такой подход 
 улучшить читабельность: все числа с плавающей запятой будут в одинаковом формате,
 не спутаешь с целым числом, и символы <code>E</code>/<code>e</code> экспоненциальной
 нотации не примешь за шестнадцатеричные цифры. Помните, что число в экспоненциальной
 нотации не является целым числом.</p>

<pre class="badcode">float f = 1.f;
long double ld = -.5L;
double d = 1248e6;
</pre>

<pre class="goodcode">float f = 1.0f;
float f2 = 1;   // Также правильно
long double ld = -0.5L;
double d = 1248.0e6;
</pre>


<h3 id="Function_Calls">Вызов функции</h3>

<p>Следует либо писать весь вызов функции одной строкой,
 либо размещать аргументы на новой строке. И отступ может быть
 либо по первому аргументу, либо 4 пробела.
 Старайтесь минимизировать количество строк, размещайте по несколько
 аргументов на каждой строке.</p>

<p>Формат вызова функции:</p>
<pre>bool result = DoSomething(argument1, argument2, argument3);
</pre>

<p>Если аргументы не помещаются в одной строке, то разделяем 
 их на несколько строк и каждая следующая строка выравнивается 
 на первый аргумент. Не добавляйте пробелы между круглыми скобками и аргументами:</p>
<pre>bool result = DoSomething(averyveryveryverylongargument1,
                          argument2, argument3);
</pre>

<p>Допускается размещать аргументы на нескольких строках 
 с отступом в 4 пробела:</p>
<pre>if (...) {
  ...
  ...
  if (...) {
    bool result = DoSomething(
        argument1, argument2,  // Отступ 4 пробела
        argument3, argument4);
    ...
  }
</pre>

<p>Старайтесь размещать по несколько аргументов в строке,
 уменьшая количество строк на вызов функции 
 (если это не ухудшает читабельность).
 Некоторые считают, что форматирование строго по одному аргументу
 в строке более читабельно и облегчает редактирование аргументов.
 Однако, мы ориентируемся прежде всего на читателей кода (не редактирование), поэтому 
 предлагаем ряд подходов для улучшения читабельность.</p>

<p>Если несколько аргементов в одной строке ухудшают читабельность
 (из-за сложности или запутанности выражений), попробуйте создать 
 для аргументов "говорящие" переменные:</p>
<pre>int my_heuristic = scores[x] * y + bases[x];
bool result = DoSomething(my_heuristic, x, y, z);
</pre>

<p>Или разместите сложный аргумент на отдельной строке и добавьте поясняющий комментарий:</p>
<pre>bool result = DoSomething(scores[x] * y + bases[x],  // Небольшая эвристика
                          x, y, z);
</pre>

<p>Если в вызове функции ещё есть аргументы, которые желательно
 разместить на отдельной строке - размещайте. Решение должно
 основываться улучшении читабельность кода.</p>

<p>Иногда аргументы формируют структуру. В этом случае форматируйте
 аргументы согласно требуемой структуре:</p>
<pre>// Преобразование с помощью матрицы 3x3
my_widget.Transform(x1, x2, x3,
                    y1, y2, y3,
                    z1, z2, z3);
</pre>

<h3 id="Braced_Initializer_List_Format">Форматирование списка инициализации</h3>

<p>Форматируйте список инициализации аналогично вызову функции.</p>

<p>Если список в скобках следует за именем (например, имя типа или переменной), 
 форматируйте <code>{}</code> как будто это вызов функции с этим именем. Даже если имени нет,
 считайте что оно есть, только пустое.</p>

<pre>// Пример списка инициализации на одной строке.
return {foo, bar};
functioncall({foo, bar});
std::pair&lt;int, int&gt; p{foo, bar};

// Когда хочется разделить на строки.
SomeFunction(
    {"assume a zero-length name before {"},
    some_other_function_parameter);
SomeType variable{
    some, other, values,
    {"assume a zero-length name before {"},
    SomeOtherType{
        "Very long string requiring the surrounding breaks.",
        some, other values},
    SomeOtherType{"Slightly shorter string",
                  some, other, values}};
SomeType variable{
    "This is too long to fit all in one line"};
MyType m = {  // Here, you could also break before {.
    superlongvariablename1,
    superlongvariablename2,
    {short, interior, list},
    {interiorwrappinglist,
     interiorwrappinglist2}};
</pre>

<h3 id="Conditionals">Условия</h3>

<p>Старайтесь не вставлять пробелы с внутренней стороны скобок.
 Размещайте <code>if</code> и <code>else</code> на разных строках.</p>

<p>Есть два подхода к форматированию условий.
 Один допускает пробелы между скобками и условием,
 другой - нет.</p>

<p>Предпочтительный вариант без пробелов. Другой вариант
также допустим, но будьте <em>последовательны</em>.
 Если вы модифицируйте существующий код - используйте формат,
 который уже есть в коде. Если вы пишете новый код - используйте
 формат как у файлов, находящихся в той же директории или 
 используйте формат проекта. Если не уверены - не добавляйте пробелы.</p>

<pre>if (condition) {  // без пробелов внутри скобок
  ...  // отступ 2 пробела
} else if (...) {  // 'else' находится на строке с закрывающей скобкой
  ...
} else {
  ...
}
</pre>

<p>Если используется формат с пробелами:</p>

<pre>if ( condition ) {  // пробелы внутри скобок
  ...  // отступ 2 пробела
} else {  // 'else' находится на строке с закрывающей скобкой
  ...
}
</pre>

<p>Заметьте, что в любом случае должен быть пробел между
 <code>if</code> и открывающей скобкой. Также нужен пробел
 между закрывающей скобкой и фигурной скобкой (если она есть).</p>

<pre class="badcode">if(condition) {   // Плохо - нет пробела после 'if'
if (condition){   // Плохо - нет пробела перед {
if(condition){    // Дважды плохо
</pre>

<pre>if (condition) {  // Хороший код - правильное количество пробелов после 'if' и перед {
</pre>

<p>Короткие условия можно записать в одну строку, если это улучшит читабельность.
 Используйте этот вариант только если строка короткая и условие не содержит секцию <code>else</code>.</p>

<pre>if (x == kFoo) return new Foo();
if (x == kBar) return new Bar();
</pre>

<p>Не используйте сокращённый вариант, если есть секция <code>else</code>:</p>

<pre class="badcode">// Плохо - условие в одну строку, хотя есть 'else'
if (x) DoThis();
else DoThat();
</pre>

<p>Обычно фигурные скобки не требуются для короткого условия,
 однако они допустимы. Также сложные условия или код лучше
 читаются при наличии фигурных скобок. Часто требуют, чтобы 
 любой <code>if</code> был со скобками.</p>

<pre>if (condition)
  DoSomething();  // отступ 2 пробела

if (condition) {
  DoSomething();  // отступ 2 пробела
}
</pre>

<p>И если одна часть условия использует фигурные скобки,
 вторую также оформляйте с ними:</p>

<pre class="badcode">// Плохо - фигурные скобки у 'if', у 'else' - нет
if (condition) {
  foo;
} else
  bar;

// Плохо - фигурные скобки у 'else', у 'if' - нет
if (condition)
  foo;
else {
  bar;
}
</pre>

<pre>// Хорошо - фигурные скобки и у 'if' и у 'else'
if (condition) {
  foo;
} else {
  bar;
}
</pre>

<h3 id="Loops_and_Switch_Statements">Циклы и switch-и</h3>

<p>Конструкция switch может использовать скобки для блоков.
 Описывайте нетривиальные переходы между вариантами.
 Скобки необязательны для циклов с одним выражением.
 Пустой цикл должен использовать либо пустое тело в скобках или <code>continue</code>.</p>

<p>Блоки <code>case</code> в <code>switch</code> могут как быть с
 фигурными скобками, так быть и без них (на ваш выбор). Если же 
 скобки используются, используйте формат, описанный ниже.</p>

<p>Рекомендуется в switch делать секцию <code>default</code>. Это необязательно
 в случае использования перечисления, да и компилятор может выдать 
 предупреждение если обработаны не все значения. Если секция default 
 не должна выполняться, тогда формируйте это как ошибку. Например:</p>

<pre>switch (var) {
  case 0: {  // Отступ 2 пробела
    ...      // Отступ 4 пробела
    break;
  }
  case 1: {
    ...
    break;
  }
  default: {
    assert(false);
  }
}
</pre>

<p>Переход с одной метки на следующую должен быть помечен макросом
<code>ABSL_FALLTHROUGH_INTENDED;</code> (определён в <code>absl/base/macros.h</code>).
Размещайте <code>ABSL_FALLTHROUGH_INTENDED;</code> в точке, где будет переход. 
 Исключение из этого правила - последовательные метки без кода, 
 в этом случае помечать ничего не нужно.</p>

<pre>switch (x) {
  case 41:  // Без пометок
  case 43:
    if (dont_be_picky) {
      // Используйте макрос вместо (или совместно) с комментарием о переходе
      ABSL_FALLTHROUGH_INTENDED;
    } else {
      CloseButNoCigar();
      break;
    }
  case 42:
    DoSomethingSpecial();
    ABSL_FALLTHROUGH_INTENDED;
  default:
    DoSomethingGeneric();
    break;
}
</pre>

<p>Скобки являются опциональными для циклов с одной операцией.</p>

<pre>for (int i = 0; i &lt; kSomeNumber; ++i)
  printf("I love you\n");

for (int i = 0; i &lt; kSomeNumber; ++i) {
  printf("I take it back\n");
}
</pre>


<p>Пустой цикл должен быть оформлен либо как пара скобок, 
 либо как <code>continue</code> без скобок. Не используйте одиночную точку с запятой.</p>

<pre>while (condition) {
  // Повторять до получения false
}
for (int i = 0; i &lt; kSomeNumber; ++i) {}  // Хорошо. Если разбить на две строки - тоже будет хорошо
while (condition) continue;  // Хорошо - continue указывает на отсутствие дополнительной логики
</pre>

<pre class="badcode">while (condition);  // Плохо - выглядит как часть цикла do/while
</pre>

<h3 id="Pointer_and_Reference_Expressions">Указатели и ссылки</h3>

<p>Вокруг '.' и '->' не ставьте пробелы. Оператор разыменования или взятия адреса должен быть без пробелов.</p>

<p>Ниже приведены примеры правильного форматирования выражений с указателями и ссылками:</p>

<pre>x = *p;
p = &amp;x;
x = r.y;
x = r-&gt;y;
</pre>

<p>Отметим:</p>

<ul>
  <li>'.' и '->' используются без пробелов.</li>

   <li>Операторы <code>*</code> или <code>&amp;</code> не отделяются пробелами.</li>
</ul>

<p>При объявлении переменной или аргумента можно размещать '*' как к типу,
 так и к имени:</p>

<pre>// Отлично, пробел до *, &amp;
char *c;
const std::string &amp;str;

// Отлично, пробел после *, &amp;
char* c;
const std::string&amp; str;
</pre>

<p>Старайтесь использовать единый стиль в файле кода, при модификации 
 существующего файла применяйте используемое форматирование.</p>

    <p>Допускается объявлять несколько переменных одним выражением. Однако не используйте
 множественное объявление с указателями или ссылками - это может быть неправильно понято.</p>
<pre>// Хорошо - читабельно
int x, y;
</pre>
<pre class="badcode">int x, *y;  // Плохо - не используйте множественное объявление с &amp; или *
char * c;  // Плохо - пробелы с обеих сторон *
const std::string &amp; str;  // Плохо - пробелы с обеих сторон &amp;
</pre>

<h3 id="Boolean_Expressions">Логические выражения</h3>

<p>Если логическое выражение очень длинное (превышает
 <a href="#Line_Length">типовое значение</a>), используйте
 единый подход к разбивке выражения на строки.</p>

<p>Например, здесь при переносе оператор AND располагается в конце строки:</p>

<pre>if (this_one_thing &gt; this_other_thing &amp;&amp;
    a_third_thing == a_fourth_thing &amp;&amp;
    yet_another &amp;&amp; last_one) {
  ...
}
</pre>

<p>Отметим, что разбиение кода (согласно примеру) производится
 так, чтобы <code>&amp;&amp;</code> и оператор AND завершали строку.
 Такой стиль чаще используется с коде Google, хотя расположение
 операторов в начале строки тоже допустимо. Также, можете добавлять
 дополнительные скобки для улучшения читабельности.
 Учтите, что использование операторов в виде пунктуации (такие как 
 <code>&amp;&amp;</code> и <code>~</code>) более предпочтительно, что
 использование операторов в виде слов <code>and</code> и <code>compl</code>.</p>

<h3 id="Return_Values">Возвращаемые значения</h3>

<p>Не заключайте простые выражения <code>return</code> в скобки.</p>

<p>Используйте скобки в <code>return expr;</code> только если бы вы использовали
 их в выражении вида <code>x = expr;</code>.</p>

<pre>return result;                  // Простое выражение - нет скобок
// Скобки - Ок. Они улучшают читабельность выражения
return (some_long_condition &amp;&amp;
        another_condition);
</pre>

<pre class="badcode">return (value);                // Плохо. Например, вы бы не стали писать var = (value);
return(result);                // Плохо. return - это не функция!
</pre>

<h3 id="Variable_and_Array_Initialization">Инициализация переменных и массивов</h3>

<p>Что использовать: <code>=</code>, <code>()</code> или 
<code>{}</code> - это ваш выбор.</p>

<p>Вы можете выбирать между вариантами <code>=</code>,
<code>()</code> и <code>{}</code>. Следующие примеры кода корректны:</p>

<pre>int x = 3;
int x(3);
int x{3};
std::string name = "Some Name";
std::string name("Some Name");
std::string name{"Some Name"};
</pre>

<p>Будьте внимательны при использовании списка инициализации <code>{...}</code>
для типа, у которого есть конструктор с <code>std::initializer_list</code>.
Компилятор предпочтёт использовать конструктор <code>std::initializer_list</code>
 при наличии <i>списка в фигурных скобках</i>.
 Заметьте, что пустые фигурные скобки <code>{}</code> - это особый случай и будет
 вызван конструктор по-умолчанию (если он доступен). Для явного использования конструктора
 без <code>std::initializer_list</code> применяйте круглые скобки вместо фигурных.</p>

<pre>std::vector&lt;int&gt; v(100, 1);  // Вектор из сотни единиц
std::vector&lt;int&gt; v{100, 1};  // Вектор из 2-х элементов: 100 и 1
</pre>

<p>Также конструирование с фигурными скобками запрещает ряд преобразований целых типов
 (преобразования с уменьшением точности). И можно получить ошибки компиляции.</p>

<pre>int pi(3.14);  // Ок: pi == 3
int pi{3.14};  // Ошибка компиляции: "сужающее" преобразование
</pre>

<h3 id="Preprocessor_Directives">Директивы препроцессора</h3>

<p>Знак <b>#</b> (признак директивы препроцессора) должен быть в начале строки.</p>

<p>Даже если директива препроцессора относится к вложенному коду, директивы пишутся с начала строки.</p>

<pre>// Хорошо - директивы с начала строки
  if (lopsided_score) {
#if DISASTER_PENDING      // Корректно - начинается с начала строки
    DropEverything();
# if NOTIFY               // Пробелы после # - ок, но не обязательно
    NotifyClient();
# endif
#endif
    BackToNormal();
  }
</pre>

<pre class="badcode">// Плохо - директивы с отступами
  if (lopsided_score) {
    #if DISASTER_PENDING  // Неправильно! "#if" должна быть в начале строки
    DropEverything();
    #endif                // Неправильно! Не делайте отступ для "#endif"
    BackToNormal();
  }
</pre>

<h3 id="Class_Format">Форматирование классов</h3>

<p>Размещайте секции в следующем порядке: <code>public</code>, <code>protected</code> и
<code>private</code>. Отступ - один пробел.</p>

<p>Ниже описан базовый формат для класса (за исключением комментариев,
 см. описание <a href="#Class_Comments">Комментирование класса</a>):</p>

<pre>class MyClass : public OtherClass {
 public:      // Отступ 1 пробел
  MyClass();  // Обычный 2-х пробельный отступ
  explicit MyClass(int var);
  ~MyClass() {}

  void SomeFunction();
  void SomeFunctionThatDoesNothing() {
  }

  void set_some_var(int var) { some_var_ = var; }
  int some_var() const { return some_var_; }

 private:
  bool SomeInternalFunction();

  int some_var_;
  int some_other_var_;
};
</pre>

<p>Замечания:</p>

<ul>
  <li>Имя базового класса пишется в той же строке, что и имя
 наследуемого класса (конечно, с учётом ограничения в 80 символов).</li>

  <li>Ключевые слова <code>public:</code>, <code>protected:</code>,
  и <code>private:</code> должны быть с отступом в 1 пробел.</li>

  <li>Перед каждым из этих ключевых слов должна быть пустая строка
   (за исключением первого упоминания). Также в маленьких классах 
   пустые строки можно опустить.</li>

  <li>Не добавляйте пустую строку после этих ключевых слов.</li>

  <li>Секция <code>public</code> должна быть первой, за ней 
  <code>protected</code> и в конце секция <code>private</code>.</li>

  <li>См. <a href="#Declaration_Order">Порядок объявления</a>
   для выстраивания деклараций в каждой из этих секций.</li>
</ul>

<h3 id="Constructor_Initializer_Lists">Списки инициализации конструктора</h3>

<p>Списки инициализации конструктора могут быть как в одну строку, так и
 на нескольких строках с 4-х пробельным отступом.</p>

<p>Ниже представлены правильные форматы для списков инициализации:</p>

<pre>// Всё в одну строку
MyClass::MyClass(int var) : some_var_(var) {
  DoSomething();
}

// Если сигнатура и список инициализации не помещается на одной строке,
// нужно перенести двоеточие и всё что после него на новую строку
MyClass::MyClass(int var)
    : some_var_(var), some_other_var_(var + 1) {
  DoSomething();
}

// Если список занимает несколько строк, то размещайте каждый элемент на
// отдельной строке и всё выравниваем
MyClass::MyClass(int var)
    : some_var_(var),             // Отступ 4 пробела
      some_other_var_(var + 1) {  // Выравнивание по предыдущему
  DoSomething();
}

// Как и в других случаях, фигурные скобки могут размещаться на одной строке
MyClass::MyClass(int var)
    : some_var_(var) {}
</pre>

<h3 id="Namespace_Formatting">Форматирование пространств имён</h3>

<p>Содержимое в пространстве имён пишется без отступа.</p>

<p><a href="#Namespaces">Пространство имён</a> не добавляет отступов.
 Например:</p>

<pre>namespace {

void foo() {  // Хорошо. Без дополнительного отступа
  ...
}

}  // namespace
</pre>

<p>Не делайте отступов в пространстве имён:</p>

<pre class="badcode">namespace {

  // Плохо. Сделан отступ там, где не нужно
  void foo() {
    ...
  }

}  // namespace
</pre>

<p>При объявлении вложенных пространств имён, размещайте каждое объявление
 на отдельной строке.</p>

<pre>namespace foo {
namespace bar {
</pre>

<h3 id="Horizontal_Whitespace">Горизонтальная разбивка</h3>

<p>Используйте горизонтальную разбивку в зависимости от ситуации.
 Никогда не добавляйте пробелы в конец строки.</p>

<h4>Общие принципы</h4>

<pre>void f(bool b) {  // Перед открывающей фигурной скобкой всегда ставьте пробел
  ...
int i = 0;  // Обычно перед точкой с запятой нет пробела
// Пробелы внутри фигурных скобок для списка инициализации можно добавлять на ваш выбор.
// Если вы добавляете пробелы, то ставьте их с обеих сторон
int x[] = { 0 };
int x[] = {0};

// Пробелы вокруг двоеточия в списках наследования и инициализации
class Foo : public Bar {
 public:
  // Для inline-функции добавляйте 
  // пробелы внутри фигурных скобок (кроме пустого блока)
  Foo(int b) : Bar(), baz_(b) {}  // Пустой блок без пробелов
  void Reset() { baz_ = 0; }  // Пробелы разделяют фигурные скобки и реализацию
  ...
</pre>

<p>Добавление разделительных пробелов может мешать при слиянии кода.
 Поэтому: Не добавляйте разделительных пробелов в существующий код.
 Вы можете удалить пробелы, если уже модифицировали эту строку.
 Или сделайте это отдельной операцией (предпочтительно, чтобы с этим кодом
 при этом никто не работал).</p>

<h4>Циклы и условия</h4>

<pre>if (b) {          // Пробел после ключевого слова в условии или цикле
} else {          // Пробелы вокруг else
}
while (test) {}   // Внутри круглых скобок обычно не ставят пробел
switch (i) {
for (int i = 0; i &lt; 5; ++i) {
// Циклы и условия могут могут внутри быть с пробелам. Но это редкость.
// В любом случае, будьте последовательны
switch ( i ) {
if ( test ) {
for ( int i = 0; i &lt; 5; ++i ) {
// В циклах после точки с запятой всегда ставьте пробел
// Также некоторые любят ставить пробел и перед точкой с запятой, но это редкость
for ( ; i &lt; 5 ; ++i) {
  ...

// В циклы по диапазону всегда ставьте пробел до двоеточия и после
for (auto x : counts) {
  ...
}
switch (i) {
  case 1:         // Перед двоеточнием в case нет пробела
    ...
  case 2: break;  // После двоеточия есть пробел, если дальше (на той же строке) идёт код
</pre>

<h4>Операторы</h4>

<pre>// Операторы присваивания всегда окружайте пробелами
x = 0;

// Другие бинарные операторы обычно окружаются пробелами,
// хотя допустимо умножение/деление записывать без пробелов.
// Между выражением внутри скобок и самими скобками не вставляйте пробелы
v = w * x + y / z;
v = w*x + y/z;
v = w * (x + z);

// Унарные операторы не отделяйте от их аргумента
x = -5;
++x;
if (x &amp;&amp; !y)
  ...
</pre>

<h4>Шаблоны и приведение типов</h4>

<pre>// Не ставьте пробелы внутри угловых скобок (&lt; и &gt;),
// перед &lt;, между &gt;( в приведении
std::vector&lt;std::string&gt; x;
y = static_cast&lt;char*&gt;(x);

// Пробелы между типом и знаком указателя вполне допустимы. Но смотрите на уже используемый формат кода
std::vector&lt;char *&gt; x;
</pre>

<h3 id="Vertical_Whitespace">Вертикальная разбивка</h3>

<p>Сведите к минимуму вертикальное разбиение.</p>

<p>Это больше принцип, нежели правило: не добавляйте пустых строк без особой надобности.
 В частности, ставьте не больше 1-2 пустых строк между функциями, не начинайте функцию с пустой строки,
 не заканчивайте функцию пустой строкой, и старайтесь поменьше использовать пустые строки.
 Пустая строка в блоке кода должна работать как параграф в романе: визуально разделять
 две идеи.</p>

<p>Базовый принцип: чем больше кода поместится на одном экране, тем легче
 его понять и отследить последовательность выполнения. Используйте пустую строку
 исключительно с целью визуально разделить эту последовательность.</p>

<p>Несколько полезных замечаний о пустых строках:</p>

<ul>
  <li>Пустая строка в начале или в конце функции не улучшит читабельность.</li>

  <li>Пустые строки в цепочке блоков if-else могут улучшить читабельность.</li>

  <li>Пустая строка перед строкой с комментарием обычно помогает
  читабельности кода - новый комментарий обычно предполагает завершение 
  старой мысли и начало новой идеи. И пустая строка явно на это намекает.</li>
</ul>

<h2 id="Exceptions_to_the_Rules">Exceptions to the Rules</h2>

<p>The coding conventions described above are mandatory.
However, like all good rules, these sometimes have exceptions,
which we discuss here.</p>



<div>
<h3 id="Existing_Non-conformant_Code">Existing Non-conformant Code</h3>

<p>You may diverge from the rules when dealing with code that
does not conform to this style guide.</p>

<p>If you find yourself modifying code that was written
to specifications other than those presented by this
guide, you may have to diverge from these rules in order
to stay consistent with the local conventions in that
code. If you are in doubt about how to do this, ask the
original author or the person currently responsible for
the code. Remember that <em>consistency</em> includes
local consistency, too.</p>

</div>



<h3 id="Windows_Code">Windows Code</h3>

<p> Windows
programmers have developed their own set of coding
conventions, mainly derived from the conventions in Windows
headers and other Microsoft code. We want to make it easy
for anyone to understand your code, so we have a single set
of guidelines for everyone writing C++ on any platform.</p>

<p>It is worth reiterating a few of the guidelines that
you might forget if you are used to the prevalent Windows
style:</p>

<ul>
  <li>Do not use Hungarian notation (for example, naming
  an integer <code>iNum</code>). Use the Google naming
  conventions, including the <code>.cc</code> extension
  for source files.</li>

  <li>Windows defines many of its own synonyms for
  primitive types, such as <code>DWORD</code>,
  <code>HANDLE</code>, etc. It is perfectly acceptable,
  and encouraged, that you use these types when calling
  Windows API functions. Even so, keep as close as you
  can to the underlying C++ types. For example, use
  <code>const TCHAR *</code> instead of
  <code>LPCTSTR</code>.</li>

  <li>When compiling with Microsoft Visual C++, set the
  compiler to warning level 3 or higher, and treat all
  warnings as errors.</li>

  <li>Do not use <code>#pragma once</code>; instead use
  the standard Google include guards. The path in the
  include guards should be relative to the top of your
  project tree.</li>

  <li>In fact, do not use any nonstandard extensions,
  like <code>#pragma</code> and <code>__declspec</code>,
  unless you absolutely must. Using
  <code>__declspec(dllimport)</code> and
  <code>__declspec(dllexport)</code> is allowed; however,
  you must use them through macros such as
  <code>DLLIMPORT</code> and <code>DLLEXPORT</code>, so
  that someone can easily disable the extensions if they
  share the code.</li>
</ul>

<p>However, there are just a few rules that we
occasionally need to break on Windows:</p>

<ul>
  <li>Normally we <a href="#Multiple_Inheritance">strongly discourage
  the use of multiple implementation inheritance</a>;
  however, it is required when using COM and some ATL/WTL
  classes. You may use multiple implementation
  inheritance to implement COM or ATL/WTL classes and
  interfaces.</li>

  <li>Although you should not use exceptions in your own
  code, they are used extensively in the ATL and some
  STLs, including the one that comes with Visual C++.
  When using the ATL, you should define
  <code>_ATL_NO_EXCEPTIONS</code> to disable exceptions.
  You should investigate whether you can also disable
  exceptions in your STL, but if not, it is OK to turn on
  exceptions in the compiler. (Note that this is only to
  get the STL to compile. You should still not write
  exception handling code yourself.)</li>

  <li>The usual way of working with precompiled headers
  is to include a header file at the top of each source
  file, typically with a name like <code>StdAfx.h</code>
  or <code>precompile.h</code>. To make your code easier
  to share with other projects, avoid including this file
  explicitly (except in <code>precompile.cc</code>), and
  use the <code>/FI</code> compiler option to include the
  file automatically.</li>

  <li>Resource headers, which are usually named
  <code>resource.h</code> and contain only macros, do not
  need to conform to these style guidelines.</li>
</ul>

<h2 id="Parting_Words">Parting Words</h2>

<p>Use common sense and <em>BE CONSISTENT</em>.</p>

<p>If you are editing code, take a few minutes to look at the
code around you and determine its style. If they use spaces
around their <code>if</code> clauses, you should, too. If their
comments have little boxes of stars around them, make your
comments have little boxes of stars around them too.</p>

<p>The point of having style guidelines is to have a common
vocabulary of coding so people can concentrate on what you are
saying, rather than on how you are saying it. We present global
style rules here so people know the vocabulary. But local style
is also important. If code you add to a file looks drastically
different from the existing code around it, the discontinuity
throws readers out of their rhythm when they go to read it. Try
to avoid this.</p>



<p>OK, enough writing about writing code; the code itself is much
more interesting. Have fun!</p>

<h2 id="Translation">Перевод</h2>
<p>Кислов Евгений, 2019<br />email: dev@evgenykislov.com<br />
<a href="https://evgenykislov.com">evgenykislov.com</a></p>
<p>Актуальная версия перевода:<br />
<a href="https://evgenykislov.com/wp-content/custom/cpp_codestyle/cppguide_ru.html">Руководство Google по стилю в C++</a><br /></p>

<hr />
</div>
</div>
</body>
</html>
